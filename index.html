<!DOCTYPE html>
<html class="staticrypt-html">
   <head>
    <meta charset="utf-8" />
    <title>Vu Garibay Wedding</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" type="text/css" href="style.css" />
    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #000;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #4CAF50;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            background: url("img/ENGAGEMENTS-65.jpg") no-repeat center center fixed;
            font-family: "Raleway", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            height: 100%;
            background-size: cover;
            -webkit-background-size: cover;
            -moz-background-size: cover;
            -o-background-size: cover;
            background-size: cover;
            overflow: hidden;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-family: "BogartBold" !important;
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-instructions">
                    <div class="staticrypt-title">Welcome!</div>
                    <span>Please enter the provided password to continue.</span>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" />
                        Remember me
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="Enter" />
                </form>
            </div>
        </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a6fbcc2d603735a28e2484100a83e6ff934a2fd05308b82748d07ef926b8ba6deecbac6d2466e6d92abdf1f4dc47371d2c1764cca335557dd734888beb66a38d98a997dff64bc203267e0136f38cb68e2dcee36dc2abefc1f1ab05fec238163c89d784b02ce69e3a84c8d2642b47dc379dc0343c44fdfb2990cd80ecf363cad9950ea51ddd6d397b1e5db23957f0ac765e896d0b433da4ce85e71607c2354a32a6652b833bceb7071da2530d2fecf092331c2071b1ac613797a2b2ea4a79083a837717db6379a93dae4ea1c6cb1f348010a5023ae134c2f46ce82f0872ba4ebc97a57ceedbc061f228dd0e837108518a5bda99494c6b6a755a51a592fa0f6ceded22bd8de4067151c88bebeb3b9e4fd5ea4b1e61b1a10cc0177c9b41cfff502228eace1e6dba19029e2747653356327ec4b0b37da2aaa5be805b0910b189759e8aa3eb3825f19b604686144da0146b3f04a97e190488636b29dc67a9a212686b6561f52851b98891dec60421853b9eaac4d519f42695fcb4afdac805d73f53cd00ae0670a9bb607963171736edb42d1ce1c2b4057cd4750004b8616fa63f6710f5b5760c9c11e8b592097402d447f29660475ecff280d309525692cc3bfcb518c7127e6e736663e630d1d5be62eb981b23cbe42cdd65bda7baf1f35f2ccb15dfce316c185d07abb04d143c53f45970173aad7b81a94fef01a749aaf47a5327a1ddd4c30cdb4133e1a941c7bcbbfb1e1b4191fa2d4fef4b66d2f8448101ecf702d7049cb812fc86f05d7f57d9479be0c644e949871534b2f7e5573c8bbbcc5039dcb73ad3f78dfde103c9e62e5c2a79993ff6106cca255ae0d04fe71b159357cf538df6293af3bf65eb67287ae93b5ef70570064c1305ebf85df476e16423cff7fdd8fa0e9e0174c620098da561d51fa67cc5d9ac6ff22e0206d902acb7900934e1169ce4c7a545a3bc21080e82eb236121ca648b75791f7f8be20ad9fc47fa88097ae84b087d8bd194d54daf2b5574212bf8de2d77f2a68cbbd192794551b7c0938147633a73c74c94ef6936231f4f3531e319339d1de39e1a1137f6e7c5a1559a9c18e0a7e1e547e39242af292ed175dfc27a07fddf17042edf9afba79a44b7a0a2c28321ee21ed3b30256f558fc63bdd24c2a2ed1d7929018d2bbcb0d6cc14437e011545bac01a3c9a30edc7134a85d3925e5fc4ebe7f3c01e924a2a3da9d12593245e4910e577e32a4eb2409053d3e43bcfea552964dd10cdc199796e2f3d38b4eafc58ce6eb56b4717824053f66a3d3a4bfa299274fd7bd6f92284d940b979729b7115e3cbd84228fbeca240b71e002a70bd958995650cf7f3139bb9240b27eb8c554ee43bf1a46403f2597c55e39a9c99aedd749815c6ddbd7094beb4ced59de72970db301e19fa74a235e2eb6bb4037e7549f3d8d2aa2e3abbc4631ef09252c2c546407ff9fece856824a45241cf3a56818341feb017fd167d161823112a6f5e74becb2e8b8fc72b46152e3b32d48535f992189b227252b21254cfb41afc0de187068570c4827881b16f891b224c3a086147487821b5b16c2cf9e837bce6ecea2a885e7a62c81c4106141b3b17a642a558df9869e39127d3c3775e7bbe72f16f0d3ed12137bc99f34c7b67cb321cf683f5ceff2e708b3b2f169f8fa09707cd779ded87f005d454f50fe5896a096c9ea4f496c2d7669eac01083a513c3321d5ec657d3680c6260b4f4698dde5ff6ef29507537a2b4defafbbbeb6936acfd1f97839da9a68a4e4959da8e92045cf8cb959d8ab454161826b89b7e21508268d4fcd68e3df4a33b519add685b222570695d116a34f463f9ec4adf28df74d1be2e73fe9e193da6c9c09d1a18e6c30e8244b6aa5ba1a06f987167be0f65d3d92cfba5ff8a5d5ae8a88901be6a9afe839a5206fb7eb731036892584cbd741e90a1048ac097c515d8289eea799fba1b0cc120a9ea776dc4d5e250b6387e97f7d0ed4b4fd6523817f48a658de0239b8f66ffafa24e4b7cc4aa813dbfe6bc89e949f446f9aec09edf8aa9f7ee9fe95b9fa90bedda86e4a0c7e9094c3fb36d06ead9607501e38905d9bad3eb0a8cd16865f3fffcdbf912426af684b1499898771fcb5c6136051a75bf4bbe7dc508d1edc7cf4c1fec6854e6c9802f82d250f37eae9b96b171faa2326dab441d14b3d76c128e34ca3d5c527453cbd6b9eea08a0ecfc246a0d894d062d647c92a51ea2d38f56e4db82953fdeefc6275ade252934daf1393c622a9da522e8caa685af8b2814711c66c792a90a3674ee573666ecb34b96da8183725bce46c44fe8b88296e0f2d117206df99ec32cb1be7b7bc0299661ef32cb44da9461794ab4f00800380c4cbd25d77e7cd6a77b7f576199ffe8580065b62e34b75ffa2cf54003414b4401079beb8d64d4921da67ba6ea010856c76e10192c055b6d9888270b30a1f0b32d8b40ab5bbf5cfabfbebc6e5339029cd45bbecb52a9babd6d27f1ab4fb4d3e95c1daf400e896e5d4ea474a3900ea130f12b6cc0e4460e7d2fd83dd636680734350a1647b8698b1f5b7e9ba30bdc2077e337f68e39c161ada3212e55026ca0534dcb05d0a166dff6d8b12365007ce48834c97dcee2a9d150f15163ffd96057686a00101d03ab67548a5faa3f2a4922e37e94b8a8c8ff5f94a3c9bacfd99438ad8ec6d2770e1d3692a794974167568989e53209910216714428700ac49e656d35f9203602866664fcaa0fd2c65362c2c5df233db64fa2dbe746f370a776fd9ba91523fc2e80c586461897a81fca867de9d57334e5f935235877bdb4ba655fd9b34da01d8aaf0e8f0d9d5511770a914ad3e89b4f063a280ffb219f0975104d0d440f4e133810c4e93f29846cecb49887b18879da3dc62cdcebff4e600837a749c4c2542560b43d8aa7744832011f3e9537bf7cb569d41fcc5029e1ded0d0d691d61cb34721dbded161ba0d568fc5e67054aefa4f3000ea292b1debe5e2d557eec3d17ec52b88b6ccaaaabf2fe8609f92fe09034a1d71754f839392cf55af00fdc5f42fe69170dc1261834e82ce5ea4750cc250b4620b080da2befc5daf4510e47cb7a0a9feb52be8e056e398541afcb20de2cf5846f05b7a7771071cb5f0f4863d0b9c387ee2c88e20ff653c66b5062c0ecabdc001b815025d7ac336d8e357e80cdc5ea28b08ca86bab05e479f6cfe763942959b335def660affe519d9567f1ec69670140589bae70eb8afa5d0a52f51b9f257139c6df255b0683c19d1430dae1eadba7bda54aef92d81b9facca862fd3deee668bfd024e9cf38b6f4127064235aa0f8318f957e851230113d86ed807e228ff3ecc974177c640170e065236d327c208757d099a9b93ed69e8cf99ab3f90a256bf3bc8ebafc3b624f08dd398ce2e92787849186088aded380c2ab41576ecd30805b1eb842c362198f0998b5e0daaab27ced582ec36e52a80bc4d9dbf23a0a8946dd246bd4fb89e33149cd029dc55c04912f5705d2328124eb1209c981ee0e0de47e6e9fd1ff17c0ebed9d19d9749fa9a15dace34665615ef4f0c5ca9331d048fd145939efc52f305354b8ee7477ef8ddb8cea7fb02f43e0b091fa5cb7bb9c802a43a1d797101e80a0789f6b07683502b28aaacabef9e6b2bcb2e2e810324480c624f0998705240877f5e52408783f5c57b6860ca0452e144345c849a34a38485e7ce5131266ed883c6ddfcdbc7ecb20550e57fc6e12cbab7a760739239b8f85ccf9fd25513ab9b724330d6f37d8a2f282fafede0e666444a5b9a99a5f13bf3c44329f5af68d95fcc79abd647267cff305f5092d61774b7b9ca87e951b0dba96fd88b57b9c7f3c424fb1814b07247ffe5484d3936ada6176223adc4b80b6ec92710654863959cb6ed785c82eb0a999d8f590bf18474e9b14a66b0fd644e23f8b95a381c59667193eebb7fb3cba686b9018e5a000be6c88e6e7488207439f44baa86b566680c04d778b39c56a241dec73e9294b77a9aaad89f7642ec292f13fcb95ee5473d772e13e39d17db67123cf70ab73fe22c30e4ebea775bb573cd42da516a9b15507ab0c84c32deea90a3d34350ffadaf73976a2ef482d2c703e08a7f9b5c0b2f008247e1f74fa03a5fc3c1e6990dde3e1ea029df9fadc840c53ba22acea9a9ab83758b86681e12e173eade9c8a198baf5422b4c30fed14a33cd18a578399e322894b13064e008cb3b7b43bdf8cc76e2e20587980f834bab55de67debffd58859bf75fd11cda80253d4d9b5a2253f0eecea37a3c50363623a0838637d5617ef86907061d4f1ce52a9e21eaff0b4db094bab4add63d082566a85cf3c25b48a4597c8d7df136e62d488cd26024648128d32eb27b35667a21ab47f90f725ca56846bdab794a60ef572fbba702b319565427c038f218960e5b1df51f3106a68fcb6728b3e8cdea2b4c1c53c82c08e2fec8bab37f44e98b77596ea6be5e404f029a145bf996dc6bdf5296ee229071507a78395813888d2ec83083304d60fa8ac864c92d5a00b2eb086143b97d4f681cfdfa083fecad08e223b5ea6f6cce92506046c7507b09f7668f8a819eb34063bb3b76a1a85260642ec517b914e9c9ec0ceabf0fe0429576c91bbbf184402a67c813c15c28521562f907d29accb5f1607e88d3c4fc674dd167ff7ffe0e3d15cec1799ff722f2fc7f88dd726309c405e06c14a18102695c6225096c7b0dae10f1b3150144b4f9867369f80ddc700f084a1814a7d764fc1e7735b6c05d2b834cbf37b242c596c6c3143d92b5d9c28696e55a4c8540bad473cafbd9bad15b1d7c0930a0abdd307e01b00e5f4fe3158916fa8774d5e0eb7153fc46cfd34e380f72255945ff102b472fb2b75fc7c24f0f539dc5f4ef3e71a0106b3b28d2298b430be515812dede40fb71c37a775fe292fe38c1054e3111437ec8c178ed53f6dc1812436e2f5e0d03cecd00a1260e79fe767a37ee3156e1eba4199418ae5f53f67f21f78f41ac3abafa3cc880daab68b0663744f641ba88b0f09ef70d47fcef5d5cc45126555defeefb7fcf8dbda1f8ed3cb77d448aab886874dcc9f88e06c5c1bba6c8af307b2645a38aa4c46f29006dad05f17ec41fab437fbdb3636eb803c89a97e7328a5d6c84c0a7b179ca4a8948f85a1c5b026daa10c0b28995a872a4eacbde192d55332e9f49ec641c18768f52c4be12cd656358575763196a0a52c1797db574c03187921e5dc51d6395f9f2c2cfee8d5d02f1e8fb72738f6ebf1264a47069dadad7dbb3f29097ab4911faac0b3612b666a3893869f8945b82574573e2cf2b3aedcd2b1fe0141ee43a5021fbb151c43656664767a44076b2bdd0b6803b0d5e187df2e1402dfe30104a72dd6d06dd8e37e0ce1f100b9dca1db276f7a9c3fa07bd5f474eca22c7c80b3a70f48ace45910977cb6255174a0528b1f8aca079a17d5287ccba13b227825954b659aea3b61cf42f237a7c8310c88cccda7dcd172c82c270307c9413581883a1433a013732a63a004fb15e789ff6c5ef6c5a9cc436b420c6bb0717c34409966be3a4836a79dd657544e32ee6520468a80e0b9f7b8c7b2295731754cf71c67571b738d78b903f58cfa36142df02c074c91c1efe854c974a414b2a2373ee77156fb250fbdc44936270597c546d9e4d1b873b4e647b10ee5df374a6888aa63579d1b802d1643383d521028ab4b415c1c03417362b0f2fc32d4d2bfae51f3333143624acb1bd76cfb80c742eebf942ac7df3aea87a519f4ba25aacb4db7107776b586abe932884d1b96bf5749ebbc6134144795fff02cc8af65a4c70c9edde184739a294f495f2cb041690f922b54625c2d3e171ce6995cef73cd348bcefb8cd67f5b2a2d92dc8129e524e2da711b29e872c80768338172067f90d52163c02298f18a548245803aab51fdf7661450affa4130db712d6fbc11458ab8bd1d1caf0e87cac84c11a96f368bcfda6f1cd342c780a067e90625f217c28ed79bd5cc2969cc4e4a3682eb039c174ea2371fde871d96dfa894733f45a18549aba8fa7634c360681a06da2f6cccf704ee56401425ff668e9303b6bfea7bc2eb330fb49c97655ec45cec1b37c7e463426cfb248c9efb8b8c7d480d6e951f26868aa55550ecaa442e83f23a854d1db5ef1a4b607c347de14f1ea5c611dd92b77b1d5203d99cee1b9f1705fb06fd7976df3c8b6c2489a43b886687bf46d670ba2241d5ddbdf32102858e585096b9d58ccee701fdac685387acf42678281a79c02f1a69f451d81add8e2a54fbb938f7a296a651b61752cf703198133aa227a62d2c70cbc08dcf91dfb789ca54e7ecb290d961493493279026d48eaf6bbed7c198c16cd73c3b82fa689bee3b0f7c5ff7072b0ebf3f82af76c972c914f33edad8c1e721b5f32a72256f506521eee0d9d786be78a1a5c7868ab7719b64d38044f0e081c73eb963c48abaa1adf54e9e897775ca2904ba3b44d78d744b529b607fea36737f1e6d718fc87d1b51a1f3ab74c637d145a49e10d84f67ee48fd250d260a89a0fde43cc6187d8e80edbab5663c7fbb9fe9b2dadbc7587709f909ad36e679baca60e01b380f591426ac9a2665e6795e4d36f6fdc1637e150ed2ac3e1d5de5a3d70faf39f9c7e622c98262408775bc4b3834849a633614dc82c3bcd9d0e23fb476f7ebfb6d3213816b33337d26e9712f05fe27cc6a7072ea7abc3c97e2d1beb5141b85cdbb324b7ef51ce66f30d7fecb2fb9c7f9bf34b3df976cc3ff1f354bdd771ba69e73faa50c2b0db0d286f869fd4f1c34ca3dfa9b0d0d29944222451e5b48e28b66a74e7873ffa9e1d61f4e4e7d81f377e9697b7a10f27c32c357780bf8411c02a067ec27fec9ad861efad687809b69e35975f4c1e402adcf1318a594dd2e2c307b1a7314dcc9d9d514da1df4590eb04252d91e62205169fbc017ea59e3298b14f836f9bfbd65757b8c3930ede68313ee7db0d2f1ffdac596af54d4c20900dab99a15fc7547ed474af8235be0d817919e7e2817a5720ccf1c4e4d43d8203abc6baad234a7881a629af3a7b750ecebcf51bd57b30e6b3e2a583b68d511bfe7976c709aecb210d3e6fd66407c6050d59809a98dde553336a9661c4ebde6bb2208a302bdbfb3cb700efecb70df0844541cfa02b2cee0bf764a0e92d913e20baa4c013d6bbf362421f95244407742583f5ea7b8938b2dbf46030e74370190f642a7141ac70d5300ce7ba2294f78835973b1930b1428c68a861a97aa5a8911b2496b1378c092a00a14a6429fe3d679e1e9b9d2e48329829870ed2fa36e228312fdf1080076746348164c6c55d422a05b6ecf4f2200d86c0c180b9f5c8257e80b7f1bfa8cc9eb9ae74cf6b602df174efbe15cf9ef7ca664b13f5118dac4d19b721bc4739b7f146604f6a4fb61faf66c10282b5332c2a70a06fecad04cfba0a3ffaf517b04616f18b5423260fac42a47c50b5f92ddb67a5814e3a5b55d78c83b6b5cb82a5b281329905b39fd481decdc2ac1a693f1bd28beb2886c7f3204bfabe6845ca5aa3dac50fdfa10157b2d2722ab9d5cbf453a8b2f3c88c4438bb7f7698ac999b15fcf87a35d7c43d9b14b6c3cf23cfcb9f5a7d3d024abea2ef6d3bea65e786e67763a35434f4865bc9818e9a76d037dfe2853724f5b03306fa28ba59520e6bb66a05e84b0fc5527efcb33ab02f1f452a069297ce50de0e275b50d793f2b50b5ab5411fe6f1ae0f4751cffd10586df5a3a5ad61f9dd9f1098f9ae1f8492a0bc30205408121e49d3dfc19357dc592da9ac9fdac584a59745968b9b526b3cf2a8bc03b055a8c4e69302b9f9cdf676720f86965eb2da814b4184c638055bb013439eacd8d62226f40f6d886971b4f4bc187cb4bb803fe0e80e243ac0265815e7ad3aa20a7672c171292754723e3dcc0a57b9a002dd893f7ad5465466995f6ec7f6e345428f22eaa9a860a5bcd5493d18f7e87c0023733d5ed121a561456e470505134a0dd6f75f7640679961040d71b64c4a35a50a419b9e840685e5b76442acbbb184702ccee8f0804de0f5552c8f0a4672c45a3021a72b2324f7b270d4615d077fa426b022ebb458c0e8c6c5ff4f915373453db684b427decbe312c3ff70de4f07e35b7c5c0d8c7737f88c2a5d4e6b47124e3b01bb643d0f9d8e25e2a55eee74e8022cec3874eeb409f6bdab016f64bfb40bfd93e2771ce03092988cf1e4d65ab838349db1f3abf7903989bfda603a4712aafcdf7cd33ec4cc765e2223dc8f5455c84ba8540cbfd259c035b3144b51e8c927084e8b5c7094c3811f1b1549342a8d258d1f97dac88f487d41514fd54d89e436c6d6bc8ff1a0a88704284300d99024b718c436d57b89d11beff34a96d6efa69532fadaca0825ab7939c390950fa1274ec4281e72c3fcfdb50bb3ebe8f4cc31633c9347daff354fc0dc5dfa3619c690c74537263d2fc5b3d089865fa73e1a194463b64acf0b6e5c02f581a0f85e11402a620363fbe42826e3889e2e11e7708bb00cd88f22bac6ec6d441e158d5016a792239b742bd97f69c232ea9ed68e90c4e3c36d97c67332f543f03c10e0ee1de8f60d4f8747d5ebd11ece80c3ba2cfa759386008b8fe52ef866e8a5cf65970eb50c5b1c377c0ba3917a9fab3ab35f4156f9261c510fcd2f1bff69fa93b81418c13e8d1385b1d944d24f5a201f550128dee5ef4c350183aa85345712aaed7663fc8beefe23afe4475abebd94ef69570959562f9d8029d26af46579c0fd6c778eeea82fe1b3a7f143d7ad945ff8ae4dee244c2a2a22a86c0b6db49ef822491cb4ca2aeefb7cd75b5bfbab6ca3da2607e9e84f9ece5fee6b80fe763718004c6f183e5b935f17bd7de0114cd98c0a9d0445d1c24c951dea2a01281976b6b9c7400180fd44bae514a540e68451b9d0655c1731affc6cc7a558483397c5ca109a10f95aa4c3a0271f2f8c1ea1b2a3ea4782db14174e0dc7ae8d8516448f7d3a09db70b5c192fc39f31304f3bc15438e5cdcff2322a41d5fc7b3f55dbd1f23f3c5849ee19345f50a8a7679fa269beb62cabb29d370bebc5a6a30c92b0e3cefb01669359ebf12384cf3dcf3707eb7ae5a634be9fc2810778610c14e88aae35840b49321d6222520b4cd21395395862936138e7621d575ee8d4d9bee7ff7fecca3005b9a73838b1f1c371c5850257340f69cbab02f0817832818057af291a447aa32c99ceaf774b058c5653a8f27504e366f1487a044a009d025e6aa4e6b9810dbc5d1ae3ba4ad48e3c725bfbea8d73f3113c4c09543ab3a3b47afa0e9528bf18d64865d1ae071f18c3f39c9f58eb6d5846325543eb882386df961e3ff377f5cd75365824ab535ffe284d76767cf92c6bca3112041922ef14edd65e402450d08633440ee1ef2ea3d256a04228d05b149d2193594177258ad5b1c82b5a05dbd4343e53ca843c63ff6c910e5d82008c475deb32a62c588ba08715d8448244ea036d87639e4519aeacdeff9510adab6987d9295ed2b70490c92a6096e737a58e30d387736f5adf43f4eafe54e201d312216e5baba1dd3b68d148df344273d2ace08e2f309f5ce56e08431f2733e6558f2970e289140295e3c4d13c58037f7dc92cf4f13a27a21d349d2e082e28db67412bee7c7451d489fa77cff2b46b74ee019b18ab297dd2d8b4ce991f05863d0998ece78d9433ecba122070fe1d87abd312c9dab84db34226aa7501ec747a75b47c9bceb7da1f460550108c8996c730e18416f92011e434057cea2846754d3a0ce515ae21a2d6b3480293894d68e0819ec90c5d054bbab1612c45238d91636e92535a7b177f65673ccf07393c9c212520c41ab3dba340294ee1beb358ddde545a1c30656077c167f2eefbd4399e69dd20948a372c291502cba79a602819d79793cf56606dbfa356f2ab9b0cd275c7578cd8aa51c79572e9ad9ee0b95a92f5fe86ea382c035a567ea68ad5cccac5d770c5512dbef792c2f646b59b3c8a5a3e3702aecca0599f14f3d837501fb49fd03d3ffb2cc394fb956b3bcb6daa4540da5e3ebc8a1c96b225e7ba7fc914e63dfbe14fda14e63869e7824b3611fcb941f65d7d560c22172085adb80d8a1cc20ae7fa18a8ff6b465e7e51519273eea49120141d1a638b1a5c2255c492fef81c79c7523ca24bef1b8055c2a91af534e5195a7cfa318dfd36fcef7a7c10eee68360da94c8d7cfaec3e4094e2c08124dd222bee8ebf5c5b0c4bb7a057e3949c8ed4156f9b4b0c21d7ed6b22810e96345d06a26497c9c575ce2cefa5971e38618bc55775f1b16c8835c12e2104fb802a3e7fa20bb6fda1d6907b2c53f2509d9993bb70398858aa7f8ba13861e996976c97d28c7fe411a89f90b1717ac26e54876f309c3917ed8491419fa5f6c6f430013edc897f9cffa29051b64356e0d72d6bea47b89e1fc05ab845cc809da86c27087892e8f88dad1d094efe18c2915e53dc8932665be967888925033520a65eaeba3be72ab1d3e2966634104eea1d8a826bf49e6d993f72c691bb4fed701eac48611e1874bfb63f36425af81f70fed252a16aa9d9ea2c4f6545c4374136bf0dc8c8b02f67d77eb264c2f928b09b70a10b3f725b13231144d7c19df3a5058ea77d097165396b10f5b2b3bccc2c0e06d11f899ba86483e96183297bc6fe2ad81cff44f69893753853e1750583437df017c37c44cd05ab5be7a9484e143568873594db083aa60f4dcd3c7fff0946beaf99392b746850bd3e4b46faf7389a11a20b0234ca17cd282693e07f07d4f4608aab15afc19b6dd3e18166579611b9751992fe88c37968c71ca22644ae9301ab56a825f79df8bbf9ed336e1aa93a4779ea3992f7564f3e31e6c8b3b6e6482eea169845de0a131f770c0eedb5424e949b8c5daa291539b12ac1bd12ce493968737a1d2ec35a2bcd1cb819f394d149c079bb1295dd9e751f90d51fa361f260f09f83aeea4ccc143f4abd04895b96c2032fa88b172bc45fc0701b2fb20950b2aab20d4b40f0d5a8ec43c08fa76e99d29a79d386c9340442e848c9afc90b71ed22fbe99d0cf0aa8ffc9d03b8e4652fe37b023d37e91f7e5b6caf346c0164779e4b45a4ea75dc3ef658b7dd6ee627c75224380526b04ef30389bc877d16ed55fb19560e43569c42de3353a9ec11750ce54bcf86f5ca8a803b405f3222baa103f20eb0ec21955fb9f46c5728ab3f200dd6be93ab581de44574bb340bc01a5d99835949076c0aa8fe82e552bd0da2d5f9ddb0b3844e81fd96c87a874a6f965709758239809b21cc5553d6e41bee63c54eb0f2d34a4b7919bb03e34a99188f5960704ea03f175e600343605b74b6e0d789a904c8e7546c11f6c040e62060c083f3861574a0d350ee2d85252a4d4eeebd1321b30ed067d75193347832d69cc4bfbff090c95a1ad62b4bdd06e9cebcd1ed15285576cc1e77390898690dd1f35e51e8f7c5047e9fe5529c701ec29c065abbaa5e4d4b5700dbaa43f27d549c6e6bcd00bebf377acabcc0bb080c09d6eba11b1eed487eb1e4375354e8c58b27c39f7f17833a08b635e0057264f9f011dcfb7c5688e05b36b1c0c20ac6042c1185cd4cd0693678100daeae4d98ec76d998d8a613503eab195c6b64b9d6986eb75f2cdd2ad299c808aa2d54552983b059030cb39735dccefb8417539cead1d7acd83db83f3f29ffddae8a91925bac1bd6f96a0427d7ae79f2bca6d49213870db29080964998ab4d68a88c2a1033a94cc86741e8369c3175f39e657f4452fe6bca17ae107615a8048e08592342e0c3e50ef764d7f6799d4cc8b9fde5f861a625a0b55c65676f7bb6b8707465597e9428f866d690936a11725685515caf26e227b9ebc80ea564ae4446aaf508eb51f7c0d817b6248d266104bcf83a4ca36f7ae9842393ef4586d5d9a7d415f8faaea4b8f1da6b37c2fc7f588c91d22fe7436d7fdc830bd60257737a96364efeaaadf86cd4c564e366c6f0d59bbca4b5a870bb2ef490cf7c37b335e534b2409eb72b854d307444644acd011f30cc24d7075a18042f440e1e37a9da3ef3aa83d454738f173023dda4ef1bdda78497d893276a71a885cb5234f41b0986298e4204419a9ad61b5587d1a08a97757c9d7eae226f44b471fde918bae0e875055287f025e1dbafedf4e1c1d9ee5456d653f81a52b53ffac5e1227d5b5c41c216ef533ddf129ec27bc775fab6df68c871fddb11975a217e77484704b91fefc0fa98d4ea30807b3979d318e3a54fc83d5df357b528b8e97c6f56a569930741d8ca61eb5ad774923cbedf253b5385cd9ccda3aa5ccda66bd2bed9378fab91ce56edd3317f78f38839c013e3cc4a82c0bdcf26194c410771159c34e79e9e186d417b255025ab107fe9c508029aba2db6b0b88d580339a0d0a2b7fdf571f8302e57cff401377a9f87874156d94b402c2e3d16fc4571594c547766c0366056cd108fe7e1f514a83f70be36920b00f0e4a31ca657ec09f0cd550262220fdac49bc5a5b5f73138be343d09bcc60284ba94986649a39bc57e0c94494a67ea949bfc04c8d5aa76e2afc8bea3b4f28d336c514c1592cabd911cb3dc9cc01e9a96974e6280b9b5d53f046fb3c655f966ec09b155908e08e52ca22901a8e7582a88a09a2184591c0fe789b6e752575c3fd97d7a941f62e42a63a97320d345a5310ef7bc15d8115f59592933583e5a484797c47b19ecac0c43cf5c821618dc0ecb10a310972bc05424cb2cc9ae53971ba16e8797e460f5c9fd562cbe36e5a5c4acb6d9490d6f4714eefbd5fb95d512de64582540ade0dd248532eae5dc5e93fab6a06b57fd583126cbf2b87880f1d2c7a408f658746cd54667874a4b4a28c65858793ad1d83407c4ff1acf3fcca36eaa9a4851ce00e391faa14d27e6ab91a81ef0e826acde99cba45f9ad7899a654e7c30f2fe08fdaac6a2e2f9c7cf254a4823d22704a3615834b871582310d27105de87929b823ac9c4e4610c008e57cd9442058019051d0baa3995b9ab44931904bfc99233d8a4bb2f272b45ddd8de821b0f80e8974deaa02f61b868b2a3579cd4a470d03bc9a7cf4ed9600966d0bbbbae2173e8552a2bedb3d25c29d9e6791bd45c9c56639cb374215ca48a7bc49d9ab9556878f0b00ccf873c7dc3ea239b34d16ac71287f4750afd69e3e15b9f1027ce89a2998a2ba6de10467ddfc5bf9998d7b21001647b5cdc85485f33835c9fc4bed51ed3865a0b717e7bbc974f9b7fa7d5f40363d5c89428a693d566162ad8706d85f88a9b7cd1bc1de130beb4db99535f05d8e824ddcaf92d407b7d4988595f0fbd263e7f5a5edc865dcefb46b9b112b6e82d5dff669284723c772819231c5d049d2e0d174b90107218ea3e45238a5d0a55de572b5654a845dd020cbc0d0482f2c2be436a9520a29e7ece8699ec03baa5f8fba7b83ad8174e5cb99c0e24b634dc2e658132d6fffcec089b1ff91268ea6a2c160967ec71e941e53d5ee040af2a2c8d3403375002f0fa38b9ed6462fcc23d678baed144ffd2d95bb86b1128625d741a727812fb483ab6d4de67cc5e56cfa182cae01de0774d01fb39132f3c4ccc7140f229e9c808ad69856c0f24858b3e6c53ff9a8bcd3a6e13ee383fa955f5725a559da8c89c14dbec7c16bb73cf3f2aff36b314bbe25a5143e415f7c8e7121223bf5f216d0dabbfeba416f1c3ca2334e625189ac4df82299493e8c711f40a6d4ad187a7cae976718f26e40a6c37fc54d86889321143a35627507f604422b0e61518257d6145fe2627234277831c9ff4a4045292aaece58d7611f918e1f21cf5786af358bd6b7e717ee72a87a87f80ae16fe1e299febbfa38155ec55aef0e8e007f61da9db3b0cd2df60a930de243714712292c83220a66cda1f251fd56b3a584bb6e2bfd4914e961efd52e68d2e402afab72d3532c7e51293c73e56e2472f25cd242dd4a93f0ee47f009320c8334f45d72ece559a5192b35c6cc741984e320d0ae5024c605b62acc82679f21e0e9313c1d11d138478cd75f14e977e8e97385d2dedfb2479e003e5fcffea2ccaccd062d10291fbab41825b8c91e3d861229e0ef0f5534ef3f987952863ca67a6f62f985315f1e41cef88b99dafc5e14ac47b792639e92e234a3c4cb04b9076a27ae6082b4bb9f2cc2337c5704598fa01656a8a8f37afc6de62eadfc66af2c8c7f634a6a039845059c736c553f5d2de4acbd8cf3bc56050adc17da55e5c6dd18a48fc47ca34cd2dfe71ba5ee977fe1f31fe0d3e8867593ba5d1b909fd9a2193aaaf5d6168bb90f227bace85862a5e0cc9eeffd4f5b30558906d5f2e7909313db1719f4dcbc97fa3ebc56e42b9ae2dd54e45853590742e592a3af5aa3259fa16ae33d34c80948c54a04065e3d82f02b1a885f457fe54a77429cc60b470569ca0d35c99c5844bceed543af2224b5512b8b5b2276e2dac663caaa9cfabfdb11666c106c96291019dd1671a416345a718072ae128c38c7b6922c3ae6818a355d0c09a71824b353620315e373310338186120a64ddf0638d649f0d385f0578919f49db3615b32c59b2532385042fea2afa186efae6520b7e1f71b5efc2a26c7b8eea508a481b880119c29f29d9d3d1670392177f1db1dab2c9326feffbe566649fb40b937bade0f931dfb42ccb15d9e2d080c7781705881231313bec02410ff4b0b203aa4d4147e9ee903c8adf40d590a56433e83395773f56c13f159a9ae75aaa98fc26d2d7f6da87eee6fb1302e1344b17d579bcf66fc4df18dfe35c1850ab4eef451e401cc68aec5581dfaecf0bf4044c043d65075e471ffe33f7957ce9cc4cf59442ae3dd05813d2719ab8079c9e431ccfaa9ce2fd73aa07595eac7b9a599bd59f924b5c6e34e948f540ab5a401a5f91dc74e68dc2701d87a2a5df13095a8f1538eea5666d7f38c5ee8861da03c16a9a669d1ea9e23e386508bb12ee1ff45543133433a2411da81003c20e90f6a5078a28c56f275ead37f59aa679ae742c3af181e9d2fb37c32a05f20d9de108bc34afc004221a4e8c7ece230e0963e8486a45affdb8d5657e50d606ba50db82686c7bef822240298803c22f4e7b39f0c34e3c093c978f17de3972259355464fcc612eb1b5560ff15f56ee18f011de5b6da9c0b520650688f93ef2969cd955e05a72e2879ff42e89c4a1104e183a4a9e9b6a8890b444430f446a7db85f9ab8c29aec451eff8f8fb30a42d7a3f81df5fdcc3287d01ac56b0031009a323f2bd16d5ae538395906dc79cdc45a1228986689a381dc6dec6402c343921dea1b4d14515f06c6ad4ba3c538a5f5fbe62c17a4b9d801659dd4034c220984f1f1f4d5c821bc9a0a8d3410b20bd28f7eba6ef446513833ea355ea1ebf1d47016afe6371bd8dfc067aab8d510fbbb0f890aed1a0a2da307234439669fa6f6072f50fee968cd6ad37747e234c088d1622cbace79346528f5e2ac9a6a7f3e8f70395f6cd9d33f68bc0969d20c4040bbaa01f89a727f605a9c1b1ce7ba65859bea0f4b77110313140cb52720a7446cf5bb4a8baf2da8338e3ef87a3b29408b222d4cffa6f23b50a3cb3efaf23bae79b8e3f143ccad067bbf45f3580791e6ae30fc81fe134d65678fb2ef8f69d68b3fc336f705fbc42f4428296d00eec591ef8f5782b5f81ff735971d9802ff8e40cca7a614d8b3b73e09202cdfd1c559f9358fa6af7ef7dd9cd3059f6e71e461352d69871d17d6175de7b80208ba2453b01239630b5eda2a525d43d6f2ade0190e8668d3139f8a3507ea0a369a8ab8a4ff95071cbc703ea396cad291ba08d56cd4070d73d0c3f83177671187bfff9485c9227c16ede3b09b63f3dc928cd5229850cd4446fb16c870a8f7d520bf6397c6d5d338ea26efab4f06e535a9ed4367b3a10d95ed714a3f8fb521be6114d78d8d5ae6ba954cb880ae3c3c883da1b0d1d2528718cbafe9154d1eaa13cb64c53b00027ba986e6eb7a4afdfda843b3c16992cb635d6f3227692fc1812a64368b6431a9a3113a694ef79caa5fa07ae30fa07cc68c48d3907995221c3c6c055909988b95fd0c3c49b92fb410cc94e024369a8b24146366a73f80c699f37eb53e64703afb2533153863e839348b7ab44fd2992c07a1efd10005563b09fc724cd1544326d0566fb7c844be81862f7532f4f1959481541541957311903b873a8243c6a732013d0aaa50d7fdf1b29ee7e98d03912c28521603ba7015566f591f38703a8a66997dffddfd6260f62539c31ff381ea6339bba11ff547c3b1ede8df8e706329a4b189d490c02eb38c73dcdf8ed9244829c7fa00958de18eb15c34474e5b3e83ded6003a680c730c4392fdd9e1f7e6cf9a72ba5bb8bcc3924f80fec3bbfb05bc5b3c1a6b4041330cfbaf839fe5b8334f3d87ba252cf99827cd257334c5526fafc4ff45641171803ab20ad74d36f86ecbf3ecab3eff712f6ad41abac69fb00453061d0a5b6ece635461c822f81e44df908f589623f2605c07c0a18e073df90c59a1a96b11d1ad4c2809dc8496360501ab8afba37af79b54a21ce9e47226fc3021e5dc9ed76540138f98971f74685ae41ce2a22c329c5864432e9f073755c9004de899576d83d2861af426be5d42e2bfcf4ac5d075935f57f28ac99e1e99f70eb641b8935a902aa649c247917aebc0046edacc17cfdb86804e396c70804e746395bad5987f193607e192e992dc176743ed7b40ba68d62e92bf6aa79d0b3369c7bc35ebe6035a14a566decb54d99e5b7702fcc9caaff201a60ef9cbb648bddff6a2f1a7e4d6bef200e301508795e7c3c422cbdbbfb82260457dff46d2bf51113bb06f494bc036f56b7ff2d13ab51fc3fb79826da4f67481e381f30b3b913e7bae3452a302990ddf2d7d9242fc5d5206bf5c33183cbf514ead1fbd284a676ecaadd31a29ea9ddc7e4d76a83ec5260e715ea316fa16a0e2391a5995390495bb57456326d3fde82f39e7a326fc5877f36943b50831f325fd4317e26cf588ec5eb3707a6f9f9afafb048e29f95c458c898d8994131d8aa694e1091d32a4bf58b1418df93f473835c015745162ae090f0416041b53e1a66f01e636219f5b0c89c76c63339193a06e003e7214acb94ca1dab2c0df95487bf8cb79ef604627c08f424297928f763ec8df643cc71783b5d1962f404a05016194b143bb1bdc1f118c8d12446c012c65141226edaaf358e599f93951195b65dca37f2222c70f7e3a317788667c9de7c67a9ae361b935db11fa65d9520c02e520e1ebec2d247386c74218547286b16308165dc49d0a6cf75162e537f6160db93148e79f4d1ca34b8021ab40ae61c648824b4d4598b9e92affd3ca3e620f8605897d44ebbd0daa303599a1e341b46091740ea91916dd3fa2bcb73eeeed07aef13bc1d277a4ef0419fbf451416f98154943216eb74402baf1a18888d5a2d5a545a9774e1fea5e6efcbd930b69298630f1259cab43df32bf7ecf86c6b046becb095d0d28b0fa36f44cfd5eb640b94f86f6171217eea5c623a46adff94f50e98505a5ec96c6032f59860585fca697833863247dd78c6289ec57884fe093eb4cbc0a1c298e687f33f288deca07d7901dace2a682f0e0caee8a55da492c9e3c71769367dfd89c63a5d800ad73ad6fa9aebef8ef8b815da19dcaed5c1d2b687558077c25a59bed07bcadb8c7e9b9917932c0b58bc04a163723ca34d86a45f8b0d930a9a4ab1e57b46154ba017a5694f9b4bb12541cfaaa2b28794c6f5d4b8ea1267fa8d6e995927b2f6f083c7b54dc511687176e6ebd7b6198dc330ecbd4a3d4b41f6da7ead1b7b2085acd7e385e435ad40fc642b229cfc1ffc81c8e218dff3e2a3fd9255228ec2f90f5df1de3bec96972fa6bb2caa0bcef74d47fdf1143d5bc11ca9cd65f524d8fbda264361d38786d2b72763a280274c7d8d08066bdac99b1e1ffa4e5c48ce0dc2925b3e20599ea8fbf603350cd6ae8f4a9d53c3ac9dd3efa472f4b46766d09efbeb821b528ebd00fe35e9b6e340b97ba3043de68ea47c991e7da29749691d09e3f298a03a878d293481481ea3d22533b1e814effe6be160cc7582fc5628e8fe18becf923b830f2c8f73766b470e102bec8f4adbb3eb770f4d548bc9b2827f2dd307d2f78a39692c8efb71a3b92ecfe79f85232263bbc183c58a3ec224c23566865660fda8a1b67d8398a3c44d905ecd268ca08bb0aa6e0ed57452835959b1b449286e0071b4565d6b8291b5115668752e19718e53afca5830667be34c8f6a89d3c3f116129a12384c4aaed26e244e9ad1174ea34277955cd80cdd74fb740db052b8beb44ec942351a39c06e77973e9f6f81ad3b704408ea4ba05e79125b7f4ec37b378e8d34308b87ed7379c1afc127c98e244f9dfbdeba6f008a70ac9b341657e846f5f8aeb5fd314ef62b3a6487d8256f0f2b552b92b0c99c8b5454a974e22a7aeaea081762fbbc6437cb0414dc3a040a22e0267315eaa97fada08e367d92319074ef69da0b37546eb52705e9ef1a39140e6c7468c38a91aef6b3d6c8e082caa916f2ab5edeb8b1089d86d22c576d333b27f631138f8bc96b2a38d84c08cf8e725fea2e09d6b55e049c9498c804bf110f3c2e7b584e8ffba7d1093568c6ce2985fac9b847341eca70c15ca74523834f75bc3a3c89f544b39d8b997104db29e86e4c4de2b65cae843ba68c6c1b20fbb6a1ba832c5b6e0ead44a9fdcbf9fc74fc289f68b4f04aeb9e9da51051073b59a9b5ec5b696817e189167b05e8cb89a239aee9f7606ef952a4f1648a4887926e1db401bb93bccb1fb7c75fc9f064e50a809eebe9f4b3bbabcbfea4572cc1939c7a362f96f27ffe719f3305335123cc69654fca20c9a27f3ff2e5f435da21f13019d6410c1a16e952ad8e3cac29b47027ba1c3fb962d8ebd129279484ff0d0f8387352de7841c45e65fccdaf7188af5c74047ccb8ce4e632374867455e854a4c8f68f71810b17b833fbd8091f381027345464854a12cafa70ae318aa2253af9cd522dbe85673ef93d3118c902ca7c1dd55afa654007891a70c3bb15ac41926ac3e5592a9f0ce95cf566e50daf5932b075ff7f0cb8771593146b2f23e26f08a7bf4b4ef0e25efbad57f3491e9d17e2fe46b58c914922a96b440015e9c5ed86b5065ee62f4eea","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9994b3a3fa0f0cb266ddab079474d33c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
