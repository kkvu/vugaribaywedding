<!DOCTYPE html>
<html class="staticrypt-html">
   <head>
    <meta charset="utf-8" />
    <title>Vu Garibay Wedding</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" type="text/css" href="style.css" />
    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #000;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #4CAF50;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            background: url("img/ENGAGEMENTS-65.jpg") no-repeat center center fixed;
            font-family: "Raleway", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            height: 100%;
            background-size: cover;
            -webkit-background-size: cover;
            -moz-background-size: cover;
            -o-background-size: cover;
            background-size: cover;
            overflow: hidden;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-family: "BogartBold" !important;
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-instructions">
                    <div class="staticrypt-title">Welcome!</div>
                    <span>Please enter the provided password to continue.</span>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" />
                        Remember me
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="Enter" />
                </form>
            </div>
        </div>
    </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16b18ab0d895af0aef9da3ae05039f0b78a20c996ec037c1b9722fdb8b2ba72b7840012a742c17ed67e79c949ed198da2f59f1bcb4c7f8560b7237f1991cc64b5945da5383a6398fa238856a85bd0f8e36ecf953940deb191b571058ec815368e662cb2ac61b79b089e386b7946443631f32bc69f8ebfdad6123df3897c0922fd32704f5ac6b41ad75975d91855f31fb1bd2c036b66bb92f17cac63028797b4b4468dde69c4e83e3cd2b74807faa85969da7d66631f7a28f2cff78e5d4aff2bbd3a1a2fd92212d206333dff5b3e56cc6ad54f033bc48ea44f2356eab3a3f3105a1e6f4ea90fabf764036c42289a1f3fa775a88dd44d0c1649e55c5dfa53dd042b61b05426607357990b543ba766124aeb244bc43d6e0ec7b02f038177e884f1d161d3c10221eaba61182e29d1b8662767346dd0f82a706581827e1dc350b1c90b4576364c0be9577b8133e49ae90a2bc17fbb97201d90bc11bcd6bfd4f0b86c1dce44fa89d2ff9c6d5c5b047a952179adc1a17b908b07779259af6e1906b29c3d5908008173f17093835ec788d7bb2bd39062e9be632c0cf2945add3ac2c22f5ddfd4e64998da89f4aab870aa063802394bffa66404029cf122eecf046b1b5dc2ce87bb053b08a05c2d41686e31ac7f49d394fddc321368e364ddd52c2ebaeba826d120b071ac6bea734f2e9d5e4b13ef1bf7de89a2763d4d26caaf41b424d8eb638e8e31d4a70ed34018841fbeff392c9858b99dfd1c370da04c4af80d80327863cb9e12033ad54aebd2e139130977f649f2bb04ab709a6ec0709b9250f119b12e364145ef99b0e5f81724c138904d31f3cd3ef065430aa3f6be67c3dbf71b7bbf97440a3f74d0f94987f02ce061628c9dcd072ecea8ff5aabbe89ea3589476f2d37f2778d135c81216f88f9a79f8f04f8ce9f6e746bb07f663e36b3e51dd95ed84cc5cb5b2260fa671fcb55d409e81473e8c549aa5ead78951082b33faace9465c1cd0b25f60c0baa48094a73252cb5ff72f1d0ac0bac2fc0a03a99f6eae616105a07ebd53a2864960c1674c2bdd102bb50f639d105e8a67bb071e9812b4dc4629f75f79379ff7fbeed567017b99f2f74ccdc7b90c64325011c91a418506f984c3b4cb145e5603189ec099738698fb53ae5d1922dba17df829951c765851eb8be9d13273343445d6d7d35b6180541f446d099832b469831bac0cbede08f6fdb65545ba8f0f9b2571ab396f45a22107e870e55b7a64e129db199f160b7ad7ff03488a230de7713a91b206477b960f54fe815d1ae3d48e8f22a2649c5b628d3a8dd748b652275d8813cc9f1de038ef0b58f9248271bbcbb8b485791bf48cf50ab94c1c70689610df7612c65b1d6c091ef6b971628428c8e3b2150bf51b8c23948d1564414475e15f7f8065fbff0d6ab005908ab8af3570a0bcba6d4ee944547f614560c1d49253afe6a64691cc9919c83deb61ad90951f097e62362b1d9684450e2b293fd3bbf287bfc964ff64452c263f8d395b2f2c3974bf18d8f0d791926a22b8236b48c35326b403310260858969088b258db44ffc427c5aca087333660e24dc9de94aff22612802cc731a6c25b4eb34c68e0ce6769fe6c8397bbbd06a617a7fb6fd5c31cfb77f18e52e2578b63956c04112079892425af97c0fb1c919c8c02aab8e6eee74a3e2177f10e975748db34118a881aa74b9a5556ab63114166ac23e811b724f91c1c0949444f1302ea64169ecc068c30b7f2853339425d8017a9f1197f8ea603fdf44246992c93323b7c8379da65a4dd69b70ac492587cf7646ba513b356c53b0faf558c95aefc783d5a478d0b7d817cabcdc43d199911a60a763d0db65de83d221fe1c50702389b82e1042b491aba5c045b31d5a0cb18679555f9729e43b5971b68a2e326741755d9610db9a5d0ce233d679fa69461a4b6b088e643fec9b9fdf757977691ce247573ff885d072ac0eec12752f6b6c95776e1227e75bdbb81cab09b926f06a1d67eb69de43ff9e06f526dded3ce396dcd664288ca6a96a3b72aff0a8ebae2ba82bf3f35cf80cc23d034d0a3b0465cd2b95aeeb163620af213c9d1cea176c95c17fd03cac104766ad90a6e528c405fd638612b0ccf4ed6ba87c802f55f28c95123b9143725e506b4451b3e53b90acfc9765c17d10d398ee50ef90a91d9d283dc2158c200ca7de5b489727d40b66d56d3c77911d1644d3501b82edd968b692bb24544ce897e9bc8167fee0264891b9f5b5b23de488fb359da61df94bc2b92c6cbf4da0b41a490551a849ecee0dd680f8e2ac860e6256e7415f1a930d5630cdbd14c4fbd53cf8e4bee6e6c98b88e603743eeb9b098fc1ef3025c6badb241bac66c6873f3d0ecf07ad6c519d3737fd91408683337ced837ea9ea6abaa4a10469c72e01c249703d18df64938430134482a27d12f47bf40ddb70b16bb198c640967959791a627c7e74c31f1a889a2ab48f1d749bdc2053c2369ae012628b948e90c6cf7f3d88c748b314258dbbcbcab11a7ebe55b6f7b83b9d84f65dc76809f5712b27c22051c0747917799a1d64834ffeeca9f969448601a5a8da0713aa324d3d4a1e97cc94cccef87b432b5f55402d3f3bc75410822c559b0118dc98dfc25e24d0a2a8556d41a2a033dcad0d1290f9673e5cfb41cb0b31a960910f968e1ef4e4c2c63621dbf957758e26d07c824ea39761c935550a8a584c7d5d46437355be6fc3349fdc6bd6f0de389cf34c1ef67914ce5b71435b06613f71423a603fc7f4083b2729743d754b8bc82974905bb614d6cb0de13e6e609d1c9afebc49a20d975561fca9eb466dd8befa0aa923a89d0048da5d48461765053b4124f23a23183fd48cf7518ec1cd5cb4b062a53108d2680f03280d61e6a452a5d9690d6b00f7cd95c6fd8a284880405b0235127028a73578579c2439d38db1bcbde6977ec0aee0f731827b6e7ee50c1e028fe0c321337ced016ff5477349a666ce862a958194a93b1fa282085a83af2e23e0ac303369e05f91003d1bca9dcfb6c5516b6707a542c4b71fd3ea72fd48a5c70ebde43fb82e28d20e2685620dbdfec16a60241b18de650614c7b257b711a71f4cd18e96328e527de38f384e1d6ccabd8fa4990d06de5d917118124190452acdecd4cf0c7c4af09fb066c3a4a930d3bab9b4fe6a8a49225fec2a4c9161ad143ab9382debdaad6d841ac18adf7ca4ce86530062842cb50026d22c68a1053dfabd3038161603863e2be2df49df5ea735a664c9002d837b1de233d3e122503ee3232eb61a74590965171f572d9ce9b150724e4dedee0155d8e4d295bc03cdce96957a0546f682d18dd29e5853357d0611111a73ff5d88c3ad3dbd0e685704c68faadd48e923def9ab5b45da4590daf13c4693f24a92fe34d03e728539c8689fada7b97f9befa89ac8d4ce7b34f913e65d4257ac395c2087d9d540e372b8e8d886463034e1102397044e3e0c1bc5549e5faf69a6b3c5572a08ab42178f5ede12d86a27623ed921bb6302789fad8eacaf97930eb4241c07970f2e9e6b625b178b19d7ba4d9f0f952c37602f5d8c55b5986a586f73b226adcfae6911c18cec0a01e5479b77e9d1c2e01355aa8b58237f910d0b70a58f8bd91839d92dbcc5936b8ddda776e8392391c789fa7f86612c771a2b08711fa4924a4d3d3f35b9653dcc354235f44a6f64cde93f81dd8cb3bc6d223523f13a908445cff452267b27d9562031c765762c92da27bbed0a2104589920fdf33f04dd6c88f4cf0b7ea952f952742a387c2b898ba2eb560605617e7de827329d484b08ad67df6c1e633503afd334e3f55ff4172813bb4894141ffa93e7354529522001c89c7ac4f8fd3592c79217d501bb40a21671d34a6893dee10bfdd915e8ddd6bc5990585efd3f5bdf28ea5d3701ced5841ef306c8e9812c7f3c894892315f8eef85e6141bfbde9c754298a39bf813e89e9143ae75b6714b9184c08159519ac1d8606bb6405cb59e90770e7de7100717a78da672d4be00629386b74ceae2a31e0bc959783f48064369d79a54a3883072597d4b3099236e8ecf54c7a549a2a4c18ebd8842874eb93068a2f2592ead11c5d4284f1f5b32ae89d32aff33f8536d8e56ebf914c6e2d43d17159001791028c061b4d1296892f9deeced00cc01de53182531e9894187f989784d937903a5581b7068c35af15f72e0ca7175ceb2d1334a91050ce6f928714b750b677cea230b22166174d2d7fd8b240cfa95477ef2a333e22f5dda3c52aaa54c7ec332c56c51b117d15ef93c10055b238573e2526bbdd41a8bc968362d8618df149fb23f9bd3c8e4f029828d30124815aa39ee0fb3f6240c9204ad047793ec732ce623ad4e86d20e3c15242c430640055bdaff9e6b6d884f1302d441a4c5fb54cfd8334692418257530c76bd52ba7655c0ef73714398adfacc74ea87d82d64f616199b8ca9613bfab491ef315638a49141058ffecddebde257e884382d0dcc77f5bade646395ea8cb2da3b5f9a0fed7a783d83fec57fee9f11fb8e9f46edddd98044c6741bdc3d5773b09c805bd4aba7f1ffba36e156ac72a63d7167e9c47a2fc0ba6ac5fa0934e9d68677764a2c335f9ad80d84afb9a3d99d2514a741b969998852215e0adfefe2306ce8ce4ee20f5815ad2f649995beb66a10f5650b78167d9167e2f6c1695a37a2490997fb571f8555170c258d493b7539eaaf704a33a6ddf4db5d7a7856f7069ccb63cb2610e960c036999c2c612269bf5347d2057080b8ab28e766a9d3dfd3c8fc46634bfd02c17538eb709d6af9d0bf80eccd46633fce878f248968651850599dafdb90f0391bba7b7380b88cccf77380dbbdab0b8c3c01f54ae5ab44e17ce72305ec95934c5a1cfba8eaac429610ad6a465815134eec18d4e9c68ce5ce15b5c983009b4439f42143a5e84c285be7f4b1c84eb5bee38547344b0dfdcd19d95a90a525588c5b5e5d9032cc7b28258da68a06df5b8a4b05d5841b15be274074aefc802ecd6ace6d3b0c5d5a5d2f4376086af17a151ab1229fbf9e9956d36a83dfde781d46283756250a8ed13cecf664f30c9fd2032dbf11ee99931cfd904c6b2b82f65d1849c33481190d9bc35898d1e2ead27e603a7afc8c3b79b4dcf582a64ecbeea3032e5fa84409203300d2ad05fd33de6c0ed8e54e8c34c1673eef3abb142370d3c883e6a0964e190de4ccef6150bc11c040d2ca9f3c35df696a6521a8760e2ac7ea701ac4405d5ea21101bac1386ef5694eddf4e99201de0fb22d5109d04d6a16412a0efc3e1b764751f6d98ac56d1fdf8c1ecf50371b677bb903728eb9eb43919ce30e250811e1c387daad06e16536e938afceeb3caef5c1e68cd259913a4067a16933077b02269c9798f3f9d42e89aa0c82a273a3bf51a2c849659d749db4d7eec82ba6c3053331e3812f227df7e53be41c6a89661d4e14a9f96c1ed208c7d4b6bfdb0be128db0b0f600aca992de2f60f3f2890792ecd7472b49a0e30c5ea241fdd98bdade3783de63bd30f1656d821a5a035b5f68d03f7cd8f0b9071707317d4ec0a69643f2ae4b7fa3814dba45db1202a801304e0103dd1f8fc2982256c29273aeaffa8e5e6a445aaebec1b2a4004b29bf42b705265939ea4846c460e3a69fe6382efd847270ccc1235a15672e4f41f5b4fd965444350129aaa891bc01c03aec9ac63413101c72dd08283ec1f1a8ffdeb559ce5781d229bd3bc8c1e345181cf5b6ee35851a0d3f2078b0b88d2b45426131e9a66edb36b5d8fe294b8f1109d729dd8dc14677aa71354fd547390e8064ba563a9fb19d4076d22d027dbdfa7d061a04ac08af2ef2dfc0ba35e14ab11153551a65835b2089c58d635de764f2ecd927ddb57f4742760611df4bc70457b396ca09c833438233fe0b44e7fbf19a18e40adf9f3809d8f9c7c1c1dae25502a5c35966c74dc75ee3683e695a2ef7a10dcbcfd1d5399ee2285fabd779bad0c7a10abee2a412b04260601b0bfba533d18578d74d715004accd7e9ccbf54fac01ef30f7a55cbba710712d7b629a6f1baf32c16037969697dae651dfd8665ce655fa5d1650daf3c893bb65433b75384f4fcad6026215875561b5becc4ae363855858fee0602bb7cf3bb77b817abde878f86a8b7d392d910abd834013fc0b3fbd8f44d58620fb35979396480711da0987af6ba053c61cafb1985711e20fe073de62ef40df6259b15dfcda2edf527dd631f977ee87b2becaa5ea771d4465a26ff046a7ac21333a4e7f1404692ff7c7658935cd7583c3b7e7c72f19005454d47e10998619a7b97a8d78de67640a713be788377d1bff07150c9b45ce1c669b0ca3a719fe60e6b8dce999ae6937ce5cedbce036148f5bca7bcf2e002b6fbdc7a803c4e5bb07f640bb059d0c919ee1d65e8822d326a9d6c2e3dd381542069adf373fd01a6d6e491f9931eeb15d1ec0c79503520a7dbfa8bd0837ffa71ec3850cd52f3c12ae00557fe592ebffbe2d1d357f615e030bd299f823e326e4ae50ceef7f60250f8a2c6c0bb682f3f27953a048ef96c1c1c54cfe2f9223592cfe96df13e7560e02ab3358b3139d7c16bfa33cc662703a92307fb4a6b178ad2becaa6beda09602ce89b94214023be740028c4c5e9169c895a2dba324f23d91bbe5ec4a22ba2c064dcae456e933e60fa8da161178baa06e4876703246fb1e660362e79db0be6ade8df9410365f4ed9fc8494086553c74a53e0fee0c1152de4420681b46a8e4e6da870283cf1616246a3ab0870bb58937109ff5502384abcab5dd9f542722adc8ec9f9b6c1db6e6a075b5089b8b8e374981d05b55b460329b4c8a7fdd899821d05bcbf2d57db219ebc4973b5ba0484cdadbacfc1c8d9e65875633b0fb0e01250a2cb706a3fa0993d8b154f20a2c42c24dcbc276ea0a43458094731db94eded836570a437673ad6a9a219d04b8fd0b79593915c12da356d6e41e4f36133f5aab410f5964fd1a179d3724e7eff03886710dd64caa5acad00f3049e5f2ac950dcadd9f56f08dacc1caddb66483a1798227cb0b936aa8b3bbcfb551e17701b34b13978c6cee6229c1cb49582a6f64d6b423feaa65f9d00e35b30958c01280e8aa5a1f4157857f2fd814f6eb53d9875c363b20be7586d8d1ef62da8006ca6826c99e8523c807816081e2455b462dbc166c6f06d87c03652da71263466d23d36579ade3a1f5b0a220bf140289290ccb1cdef444f3501463e99da89b89ebcc635858364f00eb88361d73c84eb194c025931f865ffdc866d00f3f5d694162e742ce43953f281124c6b3ed2b13c1a1c3c17e897f972ca2b3f6928fa6e1bc30d3de6d9dba6dbd7c1cf00b1b1ebedf4453884801ee04d688c6fb4419fc1386a91f14cfb337b78faca001465f4886fc095e184fc38cf49d580314973b618dcad77c07a547e94eb12e74ac11653ba0d92ffd62231432e84fb555afaf55e21c7b6e2ef4df61afea840c30c4d17c1f1c74dc0cc6ddb42d17669bc051f7f646f27630af18afc866a7e02ad348d608ccf13c53854813377659d0c8eabe21e5690aff1a58cf9a7f28cff800362e01e1d0fb676abdc21b430bb7ef90a006320ce5b432151a055f837c5010c355a631cf54212b10eebd1e4c1c6b8329ff802e2ada4146040c3893cb3fe3dbe1951437f2ac60d35a6fbfedca59848e47d3086c27373068e0bab5b80253b06b1bd4b39dd8cb2b26b4f74a8b9575effddb31605048d3c06284090bd8e94243d4f426fa062a6b98e1db6e3b0343306ffd2b83e5e7212c1fe932662febba1bc8d622c0867b7ee8a284bfaae2e58233c69d15c26b3da7d724a7ab15b9d4e6eab39a17b1d1ed212434324df19f1c22c628a3f4c07db790662faf343392e83027b2b6bd03af78c0cf5051ec3d83a095b340e4097b6686ff4000f679fd6b27245b0b92ccf6c064a36a12e50cff10db43c92d4ab106ad159d8a6b50f804a80c8afc5016fba1ed4a98aeae9b7825d17489ac194d8491b5c9f1c9d1d24fa8077c2cf2d364a1d9ddf18d8de81e41bfb94a52805cda74e03a03a1cb37b037d9f0abfad9b295443678cf876d866a56c173a45a7d5e750a6f655884c957bf436986a75217519821c6abc0b1e1b2e8092c6a57572ba81b124bf49c5b4a92aad6d17e1df3f78b07e0f573f5bf3a7f2be24854f984c2d8c8d6ce8d2d503ab7911c3b4b378ce87643295c0baa9079a7c5eba611e9133c42e29ad3b8973350d67b894029522d94b7b6dc04d29811a1e956ee3db0689a419ad97525438274fccb376871a8ab8aab0b7337bdd29efaddf3746ee3b9d106bd05dbc0a4c22a7f0731c5b03359d292973b175b38cf44ff7559da425e2cd9639d140769c1b9b5bf095cf2616067adb74a3217d752311318267592955299cbe525a4c4ba0f88cee04621cb0836b818fe620d9854e6d54b8c9b28ccc95131ac29500cd68f3049d21093f992dc5d3610ccc993eedb204de520ba180cbdb7c17101d8908d64ec8d3ad367432ed935cdb42423976f14a94e453724dd17c214d2ef17a287235ac446ac137f9dceebb8987050e8a071044019571e8cbe4602b88dbfb769c7c3d342d8a821a7d879311f14ca678fa823db4bf5244284c8d0595d9385f7259faedb3e1cf0283ee5869f1962224d09b0905f3e795c48f31d365131849dc5f7142c3116bf2c20e395da4edd3985b9ab40f883d37a1956929265d846737b580e753dd9f0086c62141abfd9615b3a48d5777890f3c8b1efb04145cd5ed50b5c472d12ff29fd87362389b1d628965e0a8639af838b780f2804300ab9fdf97d4a412899fbaf7245a08e82514cbee82cf4fc87a839f9fe3eb81b64088113d457e997b5e38bb6a90f3b1199e3ebcc548fdda331aab20d1bba3bcdde7ca970b62be364d1ec7d9c0db97aa0ac11115169f1dbb5eeaef709d006cc44c0ca2abd05f0b88654f327d8b8f46aa1cd36fef3f43f99bd8b7f4e1e6869f9ac7382d01507a6c4b143768ff9de021c109252bb6923fafc57ed230f5d0e2498821c13588f392e1d489c4b3e6bc0312041eda3691101d3a51115fb06d4d846c9f548a928a7b1e7975cbea88ef3bb192bbe1f66ecaead15754816f66317d1677d9e684f14ab9063f455b2880e322bc58e800c22f723670686a9722a21c039fe143eecb8d956c91c734e4d50ed19dceba7fcda8f170333edf5c9bbf140be7bc9e004fa34b8abdf46d1a0bd25d07fba6c59c505e5f8df442a08af88e897604611c4e79120e30ee15edcc9d4ec6c31d0af5eaebdc2ec950f23cd044294e67a82b176d1d5ff75ab4e193d4c6e8eac449175bb1b649a73033f10aa1a06354d73bc9473ffc40154090840f7018967393b48c7e67ad326fe148f7727a2ecd2c95848f58fe319f3dc4fe3d6ad111045093d94bb7d081aeb2fe04eab9423315ae4d065a4a8bb121b926cbd7ddb6a04948fd2f6423db36c831c6f619309795f66f14737f9a5f71d988817b6cabd471b67f46768e24c5a4b20c817eca881e9014b068c897a2e513f3db60d5090fd540d781e445f59ab981867c4e1b94f2c98cd1bf6eafeef77d1422e7921535923a0afbf15517514189228c2c55c9933c73bb885b736264d2249362c39e6c5d4c8c8c47feb10397dd86a3631bb4fbb315f1162205dd119df35e0bae0ce55d294404881a74a1a42c8d1168fa82ad34c99a5efbfda8d4d07bbd2f68da6bfe4da6f3b12ee86088d329ad7a914d047bdd9a89da05e248985c5f73f2a13f996fbe79e6801df7a4038b95b4e10c4d14b36ad98fd6b2196ea206b82c42090cbc68e30e4e0a9e190fc636b3aa8428bb7675f2b7c08ca63620f8b202be610f8ac4d3bf0397aa2941a195a60683e1eecc982941d92d22ab9c7058cdd50da28cf862c38f3baecb49dcf2f2fee016f44ef688e46721b6a06cda62c8b56518e9990556649eec015e8f4010fea7bb18c97d1d52416a01031038dec9346829ac41c1ffb89430d8dc24decbd671f76d7ee98a468213dd7e4744a363b3a520d09e57e17b29ffb717e6ee643494947bb9a51daef4671be6365044f2ec65d8b61f6725f623c0aa8646030dd8bd733643fe12c1b22b4338f611f020a37cf17919fdf1e2972f677a6fc5de08f509a0e838c8c48c46b1af29a7d3e2f682141ffd7ccc9421c3accf88db9a3f3315bc442291b489cd89b32c53da11b96be5867375b410413fd99bf0e43925cedcb4e4ff941509574e85ea93ff028849bd7cb8f816b94eb3f0a8467f037d86a20059c6650573c909791c69d3d4197c1d8ee28bde373203dddf483ea4907554e1b83ec22895f1642a5838d1bfd8197011082a8b755f427c65c844c3de5ace932572df0add1f77089ba461d734808b717de1471721d488f6c6d9e7aa31baa32dfb471fa64e42663f809c65ed8a2415313ac4548e2d7d0407859468bf6cb85d14d22c326cd529fb6cbc69c4860671b27833a1c9cf6eb7b9cfd0c61cda8b4075a250cff54391fc29a5834191246d815a90542ca18525601136351fc4fb0818d03ac115f2f6e601e8b4cf494529b2716c6a9e90561bbc92e05c050e58287b7e4a2d281c27eac482b61ea2bd8eaac8dc7da886b32f1a5d4382adcad1b049b5dbace60b44587240d07477ac8abf3601e64a64c365727606878f5504b11870fc68cd0df01cb250a2e0a47e246c7512ba8e2baf811c5b93b837a753f1c4182b59628b5da0017c050d4c6e1b17c14185b2065e915703f526351f09464f988d14bfeb245b4ea0bfdbbd8bf0b6c4afb2537229f83fd0f279bc22c97ea4828732753f436603863164698dcf9b7853488fbfc02a414f649082fa0dbca9065b02cb89c45c602c9dc891ccf626e0f215d56bdfa5ab94b2a0cfdae5af03e6ee3ed3ad1a5562ae69e42a9d471d826249ad542fd5caabf4d49881bc43ed54420ab7d642a4e55001363c01bf34f7eed0dc6ed2d3620b9e126ffb2921de8d61ab572eb78f488eb2f778764483e89008d120560061e1b59c33e54a6cbb3dea85ab92f2f2fc7f4a4f09c1efdd61c2cf5c504180be2b75461470473d940a10ac789719145d0eca0e60c889c152cee9aa4a52686ab95458ac8267b5bee2325b0f4155cd1f386476f2b4fdfc983427cd56503bf2cf6dbec4aaa6683161f778646fc4b24e3d17e6623e417fc83da77ecc9b5c698f62968256fb21dc1a25018177f8ad3986926eb1cbb455cf614f712377d291dc0214326033b802f2bb48930b38509983e954a03fe8082ae424f9ce75181604602961c83499c864a32a1fa15d240c59b3975a0954fd4744be6d2fcb346568c65e84135ffc2990cc72ba95243a982a156389567ecfc000bd0c7128dfd4fe0d6360a876dbcbb8d21391d8cf7bc71cc5a6987e46500ab0be1b0d04e0a3ab83f077bf909355aeff3438650b9b9585abbd158a186f44fc6d4e0cb07e6b1b3242f47b0a062cbd57875da7bdfc0ef3f79401ba56d40ac9c1dc50c753bd9f645e1f52f92cbcbd07815cb9233ee3fcfc6963a61e26b8878f1951fd3612c4655c8d9b6fe960fab30ddf549504b6ca9f427daea25804c273feb3290335bdccfef7df423aec13cebde46c76f0ba333804e1afc660fab31e84859e124bd2858fc73c438e023502a5b63823352158b555b430f45aa5ef9ef54a8c1ab996ab36b65c268ef4d57e75fdd9553dbce3c53d022699326e5255439caa1c5aced9054d9e974a47c4e86cef75a2555b487a066b6a50354342f7ceacde7e015d6714b4231aa79dd95e47f04593e6b70caa24fb7ceb0d7f9452af3c3d2de09ead6a2602b5d0e401f8f2622cd8177c900c8049883bb239fc000821b4b5b497f1ee86abf28609ac9c2c98a3fe76e8812643a77918f02963e935037afcea2a42fb4b394e0c2f2dcfb31396eb46f13163265004393cd458315f720ed3fb2d828f843c41e5023ab9ce2095b4773979427ff8e4fbff91c2222bca028014385769dc6bada28544c2f9a315889354f353f38c51300ccb6a6cd7096e1e18805f4cec997b3391273fdc3600fba89c1c8acbc04b1c32add7e3350f3117627422852197a078c142ca0148dac7582f643382613cdb5551d4076a1a56c072f184ed91201e60dbd203a7c4f1a6f1ccb38c92bfb0153f49404613ee8200035d048b979fd893e8c0459dfc3ce74a291f79f7fa5c5194df17d8bc2f25184cd3dd44b174d878fa226ae6a4238f1247409e4cdb5738fa59e32ec9c611921dff3c550ac91f21eaab7610564844fbe25ac7d30d0bbdd294282c6a338b29373ab5482e89963893ce056e731bf5b7119fccfe38b9aace63a04901b128a8b5bc606da64371e4772854129c8b088ab604685a1966814ecf2d1a278ac053ea8dc40d44b4b39f5eb2cc571d393ea3b2c757194849bb8bb18bd87e5a84ad264d17fc1510c40dcc911ccbb2bcabe508ba4b7f43802e66f6483a9040d47d87f7944208a1e46364d6e914b23a0629dafa655b0cdd34446e37da17326206ddc209231501851903ab3bbabc0a7c3ecdecacfe6fbf2d4a06317a1480d192649058bf8d08384b111045a5b400c1d7b9d4872c04f171cf5551ed8d7212e293188a4603af8344c071bc8d2f9e2f8fe8b7e36368b2cc0acd3c4c49fc89690054e0bcf68360051acdeb9fb6e61b7ef7b565818d4209308cf8a8455349c505fe09559b3703ee9a6f5f042f249a8240beceff5f54c9fd575907af938f7b2d960eb61302ac89a4d9c83d650b2326a5c96e91cb5c0c847994d835c69af714ad76d6c61173b8f7e8f4db341887cf00b12b17220a6063a0c360c1b8bcaead1e12f57a4d0c14697b247422823efbcbc3fcc29227a8f7dd99d96e669f568b3d674112d0c328751365314eea15fa81bfe27ff7d8e7bfc0aae18cd35802887d95565958b6d77bc6099e56cf17cbfdf98ae48b228c195071a97d456394c7ba6d9e3cc786f68145cd1c5cc2b37d1ffc70fd13ceeff36d2f7e513cba4ab08d2f955abea44f1997a26f99e8a067ebc0460a7dd38f014720abc79074a49a073b4799b099748c63e592e68e52b1134c37d85273c89859612aae75777053af838ae9609c1ddf7e1fa97f819f9d18dcc4be62ec00dafeca2293b7e02568473935db407178d6ff79427fdccdd2517a567853fc73b5246210ae0f3bd7da0a5a5474844f884ba049721f9b99e4d584720c733643187f542b7eaa0e6ae1f809891ca710c61501cb46accc7cab50bd51d1d32e769d86238b3aab012f43169047650dbd097491c964d487e1103ec32f9fab64a2c9c4281df6165be5a835563df74faa33cf262e0a017ed708515994f49399a42aa668dc3060a89349cf18a06e08aec4a3b0e879910d9530c1db060c5b99c7eb8c74408a304bbb77a8bcb8b4a3c14560004ffd3d69f133185845126d65256d2e8791da84505a73afe1688d57b53f66235a9cc43877c66019ad65309267cf3b43fe1e0f159317a4a5b87ac5c3226652863637bda01e107a640f65ac49dd4c520dcd6582dec733eb30fff51f78e27aab0f10ba1323727d23f0774f0d69a79c8fd0531a944e00b1b9fd52ec716d552293769bee855198e02920e0834697fcf6d8471973822290b1d77fa98a01ff16ec3ecc851a7f1c47e75ff0ba36b7fb2cb8d6c2570ad952691b81466b81187621f47d56ce61eb084784c12f67b70498c2064e40dedc98e0cccbf6b32c298ce4499508b7df09c54687d09106bcd896da751c24fba1f9dd75626e30654334ac5ae30101f99d96e29733020f0b9cce0d17f076ddae19c637228cd66f14a794da1507e3d6eca369c216dd34e876fc5bf7e8fb8a5b45cf11a924b1ccb352e89f13ad396a3e370cde11e46c4faf3223817b656f303adb46e9f45c580d63ef049ca2b7279845e1bb1b93fbe8805550b561cbf9f84b856a41d9bde4224f2cea33f01e2dbe06748a3c3e3bcb57abc041d0e8b431b6b3c902b8d0f3d3d3c1188f26feab590600bef2acba23b58e839cd48605748f582436388b2572b07b4c9eeacc00628331bea4c4d5751426413bb9cdddac0611868734ed3d05a117b06173e085bd57b8ef4ae306d934fee8695e6eb2d45e419240329d450f2510a3f94c26fd02948e764cc9c132e06ef4b465a011916153c795a26d2865c19ddc7fa8eb31580e06fd4fba067d625bc8b829b0f0bd06b5a15f85b77aff8b7ed6dce9e73f77d09bd0a84147da0085320c75f242aeb3f6ba0541d6b9aa6a5ddf20d1fe4646ef654fb56fb2ae4cafdddcddbd1ea7dce1f2bfdf85a0feb37b6c385e04dd15efb1496f7e500b14b115dc8b4cc6684e470305928cec2ca1fa76b7951884a73fb652f5a0456258e37b8caacbca264a26de47817eee4ae113d2e5a5b20008618ec121034d4cf129f76501648b879d65d20e0aeb28d2417ac5ea45c682d50762d9bc4e04065ae055d625a8146befacc0afd9ff26c41cf1011c76a5482170b4483c4e7c7db5f98bb78b2dcede36e22d33d2c5cc6b4ac6686bbd21efb3c57fb6fe299ca36ac3626b768c8936e2be1aa92f0c13e459b72163fd6516f96e5699bd2011b55e427deb93ae263f03a3fdf6eaacf478ccf1eb4d520bda3839ba6b494590d7f3e6488fb0464b6bb693287002b87f9a2d5af8d456f1de157d560eec6cd589e39646a478a8d74acfa5a4674963d3fd31e163bc7d47dc5242e17d05410779f4465225132a8e6474499c2e09dc3aba3b573b89920fa81286370014c593014628fb753cce85cc776451c0671a0005878be083b35daa1e9ff8f360346133bf5c05f5f40235020f4c5e9a39fbab2f6d11a8c57f5f86d2a2308fade7dfb925a8cb58a489810481df144432c631b8adc60cff8b33d4aeb7d18dc97c4c064dadbd5df42f4c7537c1691acedec20e67fb2d3bb8775a3d8a2b3d781e91517939d04f89d68634cef9b2621b3f12c3ebba392adb93fc373346d35c3f3b67f4cb047804eb76f787e7990b26a916678480637e060d02a308e54f9297ddf384ed20cea9bdf572a1aa669f6e3cab4dd27f747bf5298ba8eca265767ee96c9a2cc0b501aaad1868c3e99b854f7783925b9eff428690c2fe01a095b8de06cc2794b6f91fd07b1e243aef4d61db45f538e8bfdc3c7bf099b8e3dbcc58322415748c5b57cf97729cc6762918060b224feb671e9796d9a091431570a33c62e8a776e7a20acfa73c2ca1c9911c3df385accef911cb3fb4414f51ca8acaeb735af340f31170c2ed721d3af104c54f515b702afca35a9aa4dfe2b5e08e5473a99fbbe99597d8ff8f747e71ad5f9a910e977c38c87b4e47e49c91f490d223ee7573d840985e78dc57f4091d9d76d19e7eb63b0c2b1c20828c8812ba5c5bd29f90260d6c1e0e90391bb082303eb88bd8b478a9fc635ffe8923a057ddb7d24eeabb633c633666fc3d47d14c20ddd243fd4ffc06fc1ced5b4f59345892e506aa40730cb3302bb49f1d7f3155d6743579010f2b4f4e4316883d261b22e3590020ff16c70257d5dcf721d80110101199bb23510eeb707821ae8974c9d287638557faaa41d99f96b564751e6bf52a74fa4069d23022a2e7cacfe9a96e4d699fb5c64c6ae809c486a607cf8bda7ee368b91387a6d018daa06a425cfc20a02c97999b3d1b91d7f8aca741f2e6a617ab13c81616a34cdf2b6ffc754cebd5c45eb0dff83d5224613dbbbfc9ba0f5c9a51fdff7d69b57152d055845ae88da947c1cbf570abc8916a896582ef3a964877e36ae1a608db68c2d5e366380abb0ad8a50af5af6ec7ff240d609042248fa222f98a2213a05dde8d644d43aea43107957e527b5a8b26c19991a0c687c21c5b87ece0858992a78b6f70b295d84984509d932bfb56cbcc07184ef2c4ea23afcc520bd8638bf10383f56b5b75347100f60781a94b2d7110ddbaae5f7b33ac1e821014c0bcad742ead37e8a546bf5e242c9f12947a9585dbc89c7178a05e085dd762eb9702f901d2ecbd9d1bfdf4a0238defdd2ae87a50d1d859ca66fd8f4315a3ffefb3c5fa3452b96ec17a3bf5c8b8ccae22cb5a23626093c7becf4ce961801c36c8f6a15c3bdcdffe7feadbac2241f8452baf766c84bc8e5473e59d3d7895c78732ab45e56c304b59f49ef14b6cabbade92c070922cd6b25f856b7daac27571f5512e0d35eef9bd42a0580cc5fdb404b13c7651557c95c9b10ace83a66fff2fe05a8ccf5c3ef408dc167f3c3486c23cc3ac1819c5ade2b833377c939864eb9e84c911fb30e1eac0153f4309036ea4a4f6051d75fd1c1de95f59d3f18ab7a3510134827209bc99978c99235d132a617d746d5ceb471582e517211d3ad7bfe4b43bceec28b630303a15e96b918b32ac61f7ff1756bd41bb57401f5f5707f15f5b2ba922ab6ab380dea27feef6e605b8ff9e796855289885c04eb90275bad283ffd221455aa8d51f3d45090478e9bf0d0e66c6cafaf1b7a318615a1f66888d78a8d278f6645e35946927f6258150ab764df9230aba35839fbb8f388dad978f59220370ba89b30a52580cfa48b228ae3e9b817bb2eaa0f820399fddf1b92dbed12d1aa9ed8cb4b94971be623c6649cc1bf2ce2ac73849b2dec4143c6c20d96ed10b7792b2d809b016ec466b67abf81b64d8c6d7a0291e525eaf92bc6588482c3bfb2efb5f289f63bdecbae48a7b5f1d5ca78580de8dc9d229537221aaf425d8c9ca60e15b863808fcc4cd890932dad16361e35833f66c63acd7f7452de34a1a59716772718de75aed432a5f7ad92f5574612ab5dbeacbf3afa1a6d9dc46a900e6ce91bdc8e332d93da12dcb0d95c0a6479f63e1bc49123019dfbcacae3e706f8aad0b44e0a1d4d8495ba6dcbf49865daa04c0b5cdb6c2ee23bb480b07efad8dc4314dec544093964fe4e179536939bd6d30c3b6907369b7a43cafa081570c3cb98d1f4a7c7dee59ece2c1276314d5f36d4b861ca68b161ac183a4125761e69a3f9ad2bd083f513051cf987e510b2735145d436a2298dc6638bb1fd3400aaebd974a069f6f436d8db5fef84257e298f00c43befb3efac7239fa50b5d60743164b29256285c9d0fe40acf9148ec5f023b40239d2de1a0848d7944e9aa2508cd69fc7652b9d18544fa1fc98dfb6978ef7753440f5a973014a0b8064221089658a29c6db1b8c1d548ca890b5ae309d3dc3b3fda616f011df316f5a8411c0a8a35e23d7d6393ee386e245e73baa3f587fa2898d0b3616d31a98d9a46b2d58a7bf712e24166ae92dd17d1ec6706f685389b3c21f23e387766b312083d156cf6d3622e3cda78ef0b20467ac48e17cf5e51b2cdf05f0ae1baf9ce30a785d2e4deb27e58e4f888ef05ca206f427a7286a25a8138efe00bc772f40d08765b146f50e7b1e7f0f9f2552b4bc7ba4f10a820f513b19a2e9bcdddf17505d3f9e89974e7fae28de50c74c7db165a9d224cf83059d7075a5b5f614a7d0be761f86c104f0c8b8c7badc7006d62ef17b32e636f16aeb17bca5c0a7884cbd185bae100817bd01e3aed09575b041e1df8bfa7c6435f94c3de405bc94a1a768b21e63f46588af659180313a0ffb240af988ce03dd134c48bb67478493e9d8b2957476e336e45f8dea951c70e603d8412de2b08a1455cd2f14e38542a177d1e08c1fd3c058253abc41c6b0c4df290c5db9c4e0fc673fec8d2de9567ecee46ffb2775d74bea1f8ee7a712d451f859979ca8681bbfceca16f83cda70f7fbcf90c0adf3027388a76e153625a6498a1234c8e3e8e81bdb0241fbe528185bc5485db8b98e4ba65fcfed79323b6d5275f485deb6f77cc8a1cd31eff3c71833d4a1a07cdcf55cc68f3f4355323dc13f18be4a0ab64bd73e05b2bb1b7bb1342658e1b0a5a2f228a6965ebcca89b9cc5627658f8e529ffec9a0235162b0859009a53cb9f6f0876c4ca138d5d108a13cdfad6815ac05ded5fef7c6b279d212f91103355be37c35c077f075474a9f06915f76c2955ca198ea2c7426263661234cb05c9e629303ff6cdf3a2c9f2c4d4b95fa23b10242b829e961837aec492807099a92664137b4464204bd99cd37a57eb5334c641f568b5610b568f71e4d5f122370763661aecdee727f8942c6fcd2550fca4a5bb9451341d8efba834f3b4070b6e9722bd0a9d7a22bfbd2be8eda63efa9ceae5ef7b7859c02171506a71ac09ef1b2cc91f0f8a9c21b41c62d84a854e561e1e1f16a67a72df0f83e1bb0374b0caa00fac48bb9e899e3d66eaf7827e891ce6f5631795755976cac02321eb5b6ffc070a99b2715864f4b14cd3356c57e58542522234dc61eecc3f26a11c38a368710c8f70afcac619573f521c4682e099aecfed255a981d71c0af702b9c27ba64d8757843a8d3638991ee04d04c1ba9f8c4f4674c9c38f3d4ad8a999927abec668c867c8b202d79741db9f8050a71cb52c923ebb3031b67e59afc565ce1c50d05db495745776e86b0fac08f4dadd1325efd07429dc9f432456db78cd5b9d047d4be1a4f55e97396989316b5fe32ed5fa11e779cb0197d70e181a2fa29254346384a5a6d17ec68e634184e4f49d1fe8b354d8f77ddfdb68f8156ed0306f1eb093b14f93d9e27fe8424d0c68e2680f25f5ac5478d219f41ccddf4e0d95bd5a3617e2987e12dc8dd858a6d99d41b05e97b658a65255d425fd40b91d3b5c90e8f49657875fd67da002112722e1251af46699ed43d751055f9e5f55bdf34e895d15d999f59ec29d12d964c996545618c892e0db3f7713aab81b7340f717f4fc91777542e264f903e49ec53924008d5b096a60a62e13366518d64778062cd15e45e290a537be88afe2f5f6652394022ae975d8d2e1a91f01291fe06d5611779d052ee9de76e965c485d885239d70bca45d341f126c02777cc0406350da6f1bf5e83069372100e6246fdf44331f5cdf1044e72832a6207f634aec73206878f33967190dcf85dd248a928280e1ea39639094def69e7fa1c2047af8c1c73b87be5158feeec19f122b09f7e04a30974b0ae9feb28c00b64f701e2c8422193ebfac6abfc826eab0ef2821cd1ee6190228af067a7190d93e4dc1efe1f0b1865d2859d1392dc97eca59555e541baab0fd812376f15de9090238f202402a308552300ba577eff45ff16d80c561c0c996058a342a161c843d74cfe99235e93b122845c11254c4597","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2dc8e7aa8de4a420330349b9a656b39b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
