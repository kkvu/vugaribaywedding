<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Kelly and Arthur's Wedding</title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #ffffff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                margin-bottom: 1em;
  font-family: "Raleway", serif !important;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;        
                background: no-repeat url("assets/img/ENGAGEMENTS-65.jpg");
                height: 100vh;
                background-size: cover;
                background-position: center;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Welcome!</p>
                        <p>Please enter the provided password to proceed.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Continue" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88215580a0f43d5bb27b370453e8c923b203335e14abdb426f5a8cdc04565ebbc928e8640615d3be1fb1071fb332de58822f24e8001480a6bd9704702f5f490a3869832ca95ba81e2c426466e21b085fff5deff12ba9feb882095c17b02814e1e4f30b876b6e01e848c8a42ddb39204a2a542fde68ec925027c6059823c9b5bd8f59fea2ee768352001a17c143d069e7996fe876c060a179d6a460dd231fb173c8acccca9ffde485a75bd0dc129b37755ea12167d95d6132509b9061d73391f7dfe57c33a7283464d2cb2ba019fd7107eab89d5cbb00d218562481a3ee75db3d268ca5633f370b6812cffd3c9958dc6debbe366678f6a6b353f98da79c2c329d381fcc0f3f62f6471fb119619a46e2048a073cee4490bc49c93fa1b25567e571afed8d12b1d726be561c7ec0c17495cf7b060def3cb1462babf91fcce85f978431bc8f0fc3afae866a2b3637e27cf7431ba6abee60903e60a56ef3b070b361782c6b6dc2da3fa73847093f4ded344f987bf251d40e69718727d5dbfc1489d604f7318984bf1556ef9e80801a0823b0d16c60562142c3012f4a0734889a3c8026f2bcdb494e68f4aa253cfad460a9d9cddb0dd5fe3a4fcc78c0903aad1bc2b8e1e4e1cb6a6f9773f525b429a04e756f0283a8f19ec2d4829207a52572b374f28d016be8ac436a8248a8ec47a7875039a1e1f521a45f60e31edac28bb9680bf3b30171afbe19d98c2c9c48940b19a1a51b7d22a6e06b8419efcaf03a2e569b23ec69cafb60831609130a6e78b27775534765d88aaaa1e8aa96aad9b6421affe005ad54dd83c0cad59442dff023ac90422dbf667a42461a74a7989c9d0d7cd9f206e256519c37e502b95745b77d01d6baa476eef867b47b57420f2ec27bb90539e7d8894a4236050c8b2382c06b92364beb5c17acb4e9138a1291b491c72fe6de5554d7656d484a335f5583a7114c14603ddb9a4853dba18ad877516f1629e6724742f7f050ee342a568fe58a631942d5403641881c2a95f13add87d00a42d6f852335e52183fb7841c546a4ab7033dce76c059108877c1925864e708c165745e2ba372ad79479d1f4ccbf3d8d8c995b3d747a5e95fb6b07b9e4f0e194c90f0808a699f3915e6b2d994f18d49fdc17a07c4bae241b5cb194eb0ada2410fb3f86f713ea3010c18cfa37c06940f3b99dd280e4ec526d987679d826e38fee1f19afeb977a00ccbb44529bd230e22465baaff6306029be8ff5614258851c5924e524ea0d833ce4f6e3bfe94a1e68aa9449047dfe9b2810a7ecb7181e4d52da3771f451001912c6270daac197b51f4c71ede3f191a149c2944ef80710430a53dd335a22170ca69e4e61b253404f6f4bed999651bb764093dc36bfd45791b757ed9408abf8274abd1e67e52a6c383a5d21430d3381e41eb47bc7014fdc86bd95d0ff7566af4e0b6ba69910a700623bcaec5ed50d802ceba7d4717fb00bcdf9b2e7b1e3653941b2a307fb0afa09d75ba793b7a046de15825c4b7a0dda710c9b6e9b0b9aa5acb4d19a78e31fabcb0b4bd22215ad8be07ce269fc009cdc8064afede6e05fa9ec32c7232ce9d82aa6f56127e6c5e2e48eef39a16fc72d44b3cf0313c6a0cd1976727a4907d3a1f281c97f8436a88380e9c3060354f7d74d7a5ff4033a81fe3d612b2ef7e00a710a00e1b819048fecd28602884b9d8df1fa735cb956390161079bcae832dc4c98014aa67509f1f01a1a6e0ffa7a52f446a1c45bbe25ec809211e5e11de2b0882d977f365e61662e040e9a81d61d2d58a6b8e74ac1d9501ef9f4fec2b31be5a5c67646ba916476b31d55347af196295d640b2079decf951674f39825cbebbd286a6163f66b22b8f850767b895e4c44928c873e34a34228584aa0febf53858105940dc754acc23115729922c4474fed66f56c79e48171d0f5ad73699159fb5f758a529d57a4fcadcca3fe2da9e58af28fb3289bb2ec541e2c651dcd2211211a8c8691b0229b19ea748dbae62d5900bc328fa89bf9ec038239d04b963774cb95583eb8f6e8f1773d0e1fb7f3c861d671d8df3461e2473d950435da516a016ab56dfa8fed62ed3d84f4256a9398c1b52ec06f4198e1dfaf768e9f6f1533a454e9ff64397c32097f0f9c8e2a08c833f91f869c7ca1b0de74efb1b1cc2beadbfe1734e6c6751d6dbf7a10ffb337459584757e13b8a5448ba53ca8f181ee37e72f7c1c4a9259e536c2257c3e94cd2cd3d9719d2b3f5dc2ae9622943c4f9efa8476b47f743f5bce8b9c76c3193bde7031f3b927269d3b87801d2f0414f05fdf068b4bb2cbaec639637c75fc46b1930f8e68b7b27cb0c0d75850c8b729f2508d302c600532fdc9bd4fcedb1efaaa5f11a60cbc0344833368521c46022410b40fcb2055a8b3ae775f25fea9e6ad2ac0801c469659d92ceea55923368590fc56fdfbdf3cb01362f94da3ba4099ea83aba3b10b2f07b650f3c1f3f11911da396e932a9f8280e94f254cfaefe128524d9cb80f84ea5e2b1b36cebf79f7740cd27773f21df0d2fbbd1a9f5539b891b9ad6992b95c5a5314cbc4d6edc4ef8c253c5a5efba629d059a50d331bd507d6adc8a3de7b8f5577b31bdba327d12adfb50fe886dac6b8399cfadad111753592f34921769918390d2493663056b0809e58b6cd4c1086ad6a9f6b9ab4fd76cee180af5707a522c0b077d4de7216c9511320a10c8116f2984ab65aae06d4a1a99ce7c79b39e46602bee0e13cbf692887cbe2fef802949aa8a3a34cdbd39120b9ea57903502807fd9e9e902c72d01dc00925ee30d498153240bbc771190010cbfda2df88faa09183779bfd16aaaee1fc13374534b8f760e3a911ba9b239788481ad833890f1d8cc67f7ff7774b983cdf2aab94844f00c62c6247eb4f3740a9950459854c8d0e90d1fa4dad5f3e1598639953a2fa09e35ae14d52009215a01ee43e010483adea2b033778744148994b0261b0d3cc10fdc570b07b4456a9672090d11460a47a2a187a84f9b96c531ccd845e930f77c5dd5f25890d3b0a86b94f87fb75efb328a51fe5b6a0560b2e58e46986da122cd7070f9358a39013e71dfbaa5238b67a0ba048e15338cae9770bf0b06f5a04452f1eb1baa7b67ba869e29d2cdf2091e4614ed9bb1441dc29b166b77ecd2b1d438fad61f0bb9254857be11aab9880244fe6f0562c7f6291372fca56cf00972200e82cb3bc86413b8bb3a5499bcdff907db853a9074f214549a095e82654054ef933b0b813b3099edca755918208daad816e8e30d98cadf9ba2ed7ee3015c1cc27f9c4651c41fcb274fc859a68e687b65c503ac9373b88d4b1dc3171b40f01ff94c7452019775ded43f6735c04156107a749544a952b04495d3a5ce9a3626e394f7bc490b4ae5d749d54d25b5f7ab467c3305878b8fa2f66624205356e7dfac3ad48e26bde03dfca65b8ab8aff50fd6e0f99c5197af46582f5afc80a0e60f07cbd88b6b2c6e29e5bf9d59760697b7b346a2b39b4154b13680f1b474064d02713a7d1ac7b5817bdd9639d525e6a46c74260e8e40e1660af8d6425f152b3905a2b621c568cc96bd4f321dffc967418c0bb1c0328c80c5645627732c4efa7f6fac08799b43be402a1042713b3a837ab774ef497a61f15fa8dd471c5105f78d759ca393623f67185b24336fe84fb50008ae16ed44c55f310743e21d3a166d9d3ed3e026292c6eda99de0c57b06f6b29623e4c0211642bdb8aa82a47ecfa6617644fab28683a700344a8edee69778b1e00a88a6b10b51e8d94f272aad885aba99e352b2ad4a597a548aee39e1a3347b69861b77f7944e1cc69e2f1a2fefecdb9b3f34ed766898891d87cdd5c9c01184b18d9e12688c970dfaea169801ae6d1c9e2830ca1ac1c69aa497cbcacb4257149559e9629cfd584cca3047b4e8ef594ffcafa281cfe45c27b489b080611d87bddeac39d0cbff28ca3f1c517fd1a21fc6f933a36ac18a884ae6cb3174c87e32515fd1c61f3690aab3ca569962789c28a70fa5909b3d0686cdc1504539ae2b8d2800397b574ad9990db6e32e49c7410b1928f13d21f2b4fd94f3fe61c2367b486625e0b79de3a2892698be7501aa9711889c2e075aa0150ae4ed022c7bf352e1f31905984d058edb0451ffd3ea4b7b24caba1a7a10b49fcca581888548269badd0cfb7d4282a6d1d16d2ef99a93b32f84d50c33bff94d1de93d9957ce3f1c49fdd9865cdf95244c1b5fcf31a821f81a02f033d2f2644a654feac08065d32d8942ec460febfcf591efeaabe21aed2b2a45d5002b435a62af300ada1ae779677ec910a32b8be399d50da9c3ef2a4c78145788039044aa87b58ab21c6b9c282d750bbbd76aa98679c3e33f1930afec4366de8445316495d04fca565fbece89a0eaf868520e662dd1956252d56696bc64c546135bc324b0f0450373000514417595f8acef6847d07d76867a1ac1b266134f74941883e5747f1742879b8d5866f3ab2edd9603eb40a8f32fb6757b61b5593a7f31fcefe43fbb67a9f2d6f445c1af5d5248ffa149d9aee1ace1ece06e64a84cfe263e90af4190c2eed2547ede7405fee591123a8b3bfd20dfa8d6a8f744f2c2dc08d27ef82bf14c483b8731de0bcf70ae935743738fada02d69264331a38d867129229947b86570ed2757904bb67a9b3f6a27435ea97d4956eac42c16de4f32f2ac90943b9015102272e9cb929cf23b82d5c1e01b501ed2c1e525ed633fcef8749677ef071af31cf64a499b62d7aa97b5c55ed5fc910b4abcc5c9c80f197a494b2fe34433453e7c2d541f4c0ed78c5d1e2da5e985f371f98432a2a6308414e1bca81a6132ecaf7b8bbc0d6eee9b9e3cff0b8c61b9c568bf04d3744136996d09f63167985f3505988e0bb481dafa1da8d5e836ecb9550b0edfa995a03a742f759da323eced790fac8e756b3ddbadec62294740db3c23d906fad1a57780006073a5ddfc9c6564b7487400248a35573efffb7ebdc3b95ecc3a91674388b0a851fc2a681154712c60c2e4df7d20221dbdb34f96b3f4cc5c09a7d333f7da504037b9353786b0ecd6669b00cd929de231b9d3e187035e3f324be7dfb35480fa8aa99feb4cfdd7d4d86aac1e8b3c25d4d6100d51121bd00054fced55fededc478fe11df77c428eb1d0fe1580edde2948522d7c908d01d1f0447ee8f597528a1c620519078d41bc79c2660f6c0400dc31edfde0de8228a5b5beb54dea76a520b079c8204c98b7bc0311446721ef036af6e2264c372b7e6070f5715065fa975ab06b120c2a2544c3061cc8ef9719ffb4e9a111b2b559d2d17196d689438a51dac64a281f86194e994f5470c23550692b123999bbd8c7a8786cc3b0fb5eee90e17dc88b2badcd5c824e48f83471c66291832f404ca50a6d2ba14b3dbc397940e0207cbdff32cbdf44fc526d8050a52bb9ca76c9a0c334db6149c307360ecd79a6ce6400e6db6263f77a1652b1dd5a25c5e391f7e19a2ab39fbdd0bd94134d31546437d13803540d4c2188f0c71afbe4386bd3fde89d99045ff7e683061adbb99692476b3779f5233b275f65c90c36e087c4d53b0ffdf339efe03ec12d14814692d54a207a4638592dee166663c131c1a3c4fec23154579dc24c21319a91b0967f0048f64208d84cd094063cfe89ef3cf8f8e5a00a0cda1dad72be1436a670a222f4acea9452b07adcae14bc22f1c1d2f571a40d59310e8186b710a68efd0928bc8136a0b7cda859bf9b96b7efa06dd0a9ef103cded87fac7018085dcf76d2082f138490fb3f69a6fbe2ef53495474258d7440377fd549019c0d5e4413e81c5380d113e4ca812add5892e80d2938814822d46b396857d762a1637110e2505fc5919336dc0a47dbea94562093c8c85bb2ed94483b62bef2cfbbec2e98846c5e24cf403489aa962cd60d7048c17c2e49c8744da58d930a24beecc0ab26fa1186267b7e73e104aa577b436806047c02f29cc0d689a1c98b681da2a5781edea929e7ee93d4f884d93158adb4c44724dff846e8d1a81961c5873679a8240a0b2967fc5ceb95e54abdd08892b9fb26be0de2cd763bf305f0329f2f5ae1549199decfec4606d7a1451a8f9e687bcd656492cfb38d4bb0acb61e8214e7c3813e9cd60f4d483cd6217997323e458e2a0e9d90e1490c7707af1bcaac283cabab40132fd959c7e0729870dd70b42e3ff37958014960e2966b2359de3c8972d65bd10f77a983753b30cef76ad16f68473374424462b8c8aa986268cbae4899c6a2a8d0eeb133f7c16f9afb860642fdf4db43eca23a2461a615b35322ac26bf6294daa18f65ef28a68ae1a39feae87dad00d44f3574852ccc74ccdcc32b3525b6e9eba45e974bf9a53f8be41643b039e1f85e6847e155d7a84d1420a39903d36be3732933ded70052655a7143918d38041d34d9c18cb6b7d890493a9e617c65986fe7cfa5e2374db35adddcea4bbd7cca4d5ff1a50c6dd53b141f45532e25c236f04eefabf2577ff1e87e328dfd94a77fd9793421f87b74b263d1942e2c14ce90080a7f7ab354ad3d902d84ee4a679f238350ef15a3cb20847baabcb89c0293b29b59bccd7007010582d920a07c1cb659ad73a4805248cd28ff299aeb6d4fef3415042c1eb390a467c0c25ff3b573faf5716db425aedb087c296d1d25833c2e9f918250b967da39fdc6dd14578a51b50e21c56bd11ac418c39038fc16cce50abe8c3d88b174e9e6cdeaaae5fd6818080a3bcd60c5c2a23928bdbba0d2ae90e5371e55946a11f36751c5ceb31bf874f64af71810d46f45c8c20655757b72cee7072f683be2b50c670dd627c4ebf20d1f31f0f22859602a1f61d04e1f5f736dc596e08cb6e8ecf4205b752e62be841a601a0e5ec621be3da4b77763796dae9b4f874fb67a281f33a29bc9dff29be908c65009ac5fa968ab7e3770724ea282886d1e124da29ccfe6c979e7a77278cbde2482d10c681be62d605337f9ea12669da8d7e590e5db11d20e32156c7586e96d1e135f87576fb41eee378fdae48adfd4f8967000f097b788040a18f2074052dda43405d0b3d17b9c995cd7446a2d21331209e19039627d0a134fbdd289a9e4d77262a3e88a721e5157cea1860546c4a90c0cbbf062a5ee2e372ffef31724475fbd60afd696022b74ffbaec62482988296185e1f7d10b34f87394dcd8547b43129f1513f98d47ed8b0dfa3c3f4a28dd2057910c5f7125c094964762e86c7897eb4fc257b89004d5a4158d8735af1ca94b10cd815a2058407de108177fa46f14329833e591ce9e7beb355bc70d7ebf70be0ea8b81517f4ec89c197f4b274f02a0f12227f440ca57a6cffba8e935a3404b15ca858fbdc7f339315759a3b80912ed49984e66ff6f7bd4f02c84cc037600a8b5acefd35217780b7dcd71e733fb8d41c309679ddc81a6ecdb16e183f9f922de3b8fa58861d6380064d9e625842b41d462d65734a637f38f7af4090b87d14154f84b0919fdd71bfa743fb1b6bca5606e862f4b44a5bb8da46b02a4f60ac05da1e15c54b4613a0e8ad2c09303e0a9f8e2eaa7ff29a648684fc2fbfb0c71473a13dc8b6f832c26a7b32aa7ac0fd673d686b01d83d8b528597f5697e7addb1324a47b73afd1733f0ef7936348433a8e3cc9f2856618edaceb6ad29a132ace0b27a4ffe312b8758a7a1ddbeb4b8ac09996f48136a2d650bca455e8fb0b88c68467d9a3aa7bdc6c2c3cd71f9cc749071db24369bebaa0184aaa6347cbb65d8c6c435b23b843ba4e0b84d0ad05eff1c349a2365b547fbf8754458cc73a321b007f3a7d6077dba8f916076c9eaa09b84bc7fe5ead72645ec797884b0f1b969bbaf91bc60ce00ddb9715e279e634c02db6f8a0575e3db2693a4c33ae585b4709aab18372b48e74d9cda102af8bfe918db9cf497ca26b08a516c3faae8e299f9b7197f17ebafefc5a6c88e5678406556edcb5b96f49d9bacc8fc4af119f0811765ae16f8e627f8d01657bc7a51682f222d44e4b913a38a2eebe5224c0979ecbda101f39f9d91ce81f033d25146261fb0ac4ddeba147ffabea7d412a99c28e35b4a25ebe3d9d91b101ddcffa52e5015e58593bc139d2e79c6de77b78704dc79bebb550facff5a88ff58ef80d947dd10c05d6c79670381c0aa7aad80505847ab3e18c100c010752b3e72fbf918339e4c00182adfa89b9e3bdccf453c2a51adacac8197b80f46d5265b57ae12cfcf64a160389587f760dea15966714ada949616d839f948e9873bb93889fa447567d5fcff9ffb1d9c9e02de599306639347db1f7010f88e09af9dd98d046b0b464852b293ee76060eed8df93d67ec293e1e8047a0d7607854de655c26f62401afe8cf0b9640fd092c7e5fdd6bf39e192b19af3520c498955bcb9ccae154ea215a34c746172aabf84a8572ee1b0314940349427365252f78487252235b6ac1da420bc74954261a2728b43e90771d24c8a07d5c75b27dd84b905d2256d1c16bddcfa9ff367f4cf4596f54f54282c9bd6e108a8a30d057dfd81c66246885eac2f0cce809730c0431ab3b6097d903b5d7d57aedd1f140ce5ca641aacaa0c2050588964166038264d7e8195f153594777fe2b9733f5c2dba0a3f6a9f01fcf1843ca7cdbfa6cbb9136e83522032d9b4e5a20a989903713825c155b808e8668082fbff151a5443ba4100feee93e43c6bbb8a09079aca053344c831c9312383d78f54adc34485f90489f77689adb8c2c84c655e79120082f0da7b25059ec9cac5930c0500edd62dc4a07d4f7b1050f84aa6609bdaea3366cc003138fff592ce699f0073f1c2ab7160353f8d2fae9a99472916fde1020989d238517d27f52a99e8b3925dafbefcb99de3abf0a039d852cc18c60eccf0902fdc640d798c05fae21c813e973c26264e83c0415324e01ddc5de29d6b1b7cc9ba1ed4a194507b906d95829cdc70f3121c53000c963cc66919a3c28a249f8b962eb747c412157251d9c29009046bd34c691b286baa82aad9b10e80c944a0d778d08a05b79c9b74dad054a29cb3a53347408e165f993f29b4810ccd8e4d3da9cfc513808e4af9a70910ef13a2fdda7f0d781f72ae25c837914a4a74c62da4685718da9c566a0d3ae26eb76ee1b0118951b1ac250de726ef8c88d48f0938165c05ab0b1bce0d3e4d16ab79aa2537afa89ca4c04ca6c17d95d52b89b7d470b32989ef0e51bf5a79b2537768eecc0c3fa3620522fe6fdd746aec617395ec3b162743517cf25f77bca193cffbd6abf34761622a72b02d2efa2c11cef7aff0d52445ec44d752eab2447d8e4172994ce42db0adc35ce0a39f11df2dac69144f9205897e3cc5a1048ba088b6718626e095bf444644d3f2b72762df15078f3d1d9821e9cdfb73c61e91e3e26d469a79c3c002b6ff624a96a9bdfb9ef84c4b7c023b752d79eba1e7159b2c63e050062f1cd81b8018e563b4b6c3d1bbe38125a5c46d9eace1641c9ae614f1f3e9fcd12d951d5bf0b16734c8dd039d48c4d730c9a1d5561c50746e1f80342ad81094fb91968308cea08a9c8813b08a6b7fbec37b61497de5eb08bf1db32c7ccbf56325de806376ded4bf2c0f00808dbcc82eb71f7d8d8658898645c6e3bfaea169f107a8c27faf026e69515830a567676e2f5a7b074a5901f6aa6982e189ae0e4db6f2327b43d5dc3557c399901c15b2e24341d6dfe877dcb9c210b660f4b9695c2da54d38a5b12250fe103f831d2686f9e1175f798b152f7b601c820eea002fe72cad78da44a796c3b1a56e5fd085fcbe8782330637a8dc53ab5729a46023605dff681f7743aa7c7a421b280d25610ccde7c1e18b0a4d97d34de8bbd514f3d3cce97abbf5799bbb0c0f8d071657d778d376638d2b46c1d51a2b4801e1fa3fb2061991ae8bb5344166756efd9318f9e5cf15384d7699e4bb5228f5a4236970edd89591c64c810642bb5222fbe6b0523f072245d6b5cf87b1d6d416f029d448677a0f75d133347318d7a8491d869bad8cd45a7f11a13f226360ca20fdbf5ec7eaa064d0f4218786e2702f373a8c5bab37fc78aca872f2782169681c7d01a18c47461b9e5ca46450ccd9c59282dc1249fcee5b6a14cd2792e97bf059fddc1ac5d76689688ca2142570c79dbcc7b4f69c51a1139bc16e157a19060855445592333a7057bd7c782dd5313d0002109297700cc212a36bde8aa9c177edcbeba8832f074244d45bd2bbf573cbeb5e2a911ee9114f56abdcad9c7da115aa48307cc44ff24eb77fb3f3bf405c466e7162ca7210575ec3c42d02f238f14b87657d430febf0fede7bec47771daafef1be9208a56a468de0e7908ccb350f2bb3b3b1e7cd39bd0caafa65c985ed99ff1852faa1627338504824bf93f00de3c2dbe699cfb2931240643279030dabefb8e5bc7c9d76e87be4858df3dcabbd62b5ef7f887f17f2db52208d2438c5bcddf419eebfa77656f6f03344835f33d8baf912f7c6fa2b39e664ca87f80cf6125216328f471f44b31c2dd1a57ab87faa0126d55ebe488ef7d5a4c4eca7fa9a811882a6f3a45b6a7494b047d1e8a710ffc10452b0f49ab1b526c880f3e9a991167ae07a9b89a27cd48739da75782dc2598afc1117f15037e5cae6c38b11bc7fe21a47266a2725b08ab677e98515373e30629f1ac5326095aa03a4e4e3660b86a98f7c83501b537418bf14d3a102fb453cdfef3c8c689be605396aa97caf9d7bc86299e3a079947eb3070c578b8f061b4a3ca367b63aaaf58397635c288000b7d9ff94478e4f21bdb877c52f458f89f4d4992007f4dbcc92adf7399167eaedebda2089ac5c971266e93f4a44595eac716c2db834f9f07c9b99f35faf54dbb02ac088dcc3ce0d1d7413745f2a0e3c474d6d7e500d13bf62acf7b8326d6a975e55c3ba1c17389f80ea147ff0f2a573ee96e84fcc14b483dcfee94e104a609387ddd7bdf8e8d8da0bb4689ed2b16e2bc2fc7b71f7c3c1d81f779a80015e04717f8c93a87c571a169a90851e96897128f858d2483fcd094a077a69840c04e083082dcc24f6e4c05fb49c163f291e0fe0b6bdc7194f83db28e73a3c6caa1edf01da5f01fddfc2172148f6669b48b941a3b5d5bf3123077485573a6fbbe1145d7cab49def2ae6a7dca4a3429aa3c17be40df2df6cb27e7aea25451876cfe7d9693e2c8155c3217e86d28c3d6a733e5e2e23e0ed1718ba7502b2296ee99aa1f2db5a8fc0376222832831ccf36c1d4d2ed55cabc87d90228ced45730415458287e261f701dfea1eea42d0895dc10a68941ebb2e8e82beda83e3d8bb377d639febd77efc55ee35806c9412f2e45be4b82041ed65fc396a447f732eeeb2a3a9b3004a1bcdb2ce8dd47499dde439b3cdedf7fb65cfcf8d90db4c4d9e1f66d6457073c185c75d093b285f2c7e236c55310f6357a7427d5ec3d61c77be133f4954e47fca3759397a6cf11aa7398bbe03978846c150cf3cb696a81f8367bc23df5ab8c52070447c8e3b09dcf760ef9b3fac824b9bc3d4c7f1bfbbc4d04024a84d493be3fdd963622a59dce95045e8626a8a69db62c272a972d48f30927bf4c6e86123b39d0ee43ac968d8bc509e72b790801fad2567aebaa4270ce2a17805b0767c85b5b81397d95b4ead887a360961721f42f740db42de651d7d55d2bbf29e61f4af5bd2fe4a645c988bc09d6f6fa9de68981c054d1c60404cd448fade09e1bed78c0b720042f906ab03bcc08327129713c759c814bdb3d34aab3890dd588156b1cfcf55b7841cef17d4b2ee34162d2dfbdbddaa573349513a7003357625a8e4a9387a7686c588506d365c4c000602cde785366a518c424cdf4f01dfd7f1725eaa0cb2a22a35addb59e834e294c532f939e1bec6c14bdbd9da1a459f9464fb78ea172beb0fc988327805a041fd524035c83ab38f1fc9a438d0ad4ca336555bc25a8e09f2211dbc99cf28515aae8b361b398424b33757cddaf3820bf6f070a526eab389627931f47a9a0cee098aef82bd10b3364fd5d0f301ac7cd3c83c15ccff8aafd979e50b302cce711d0f9d8566c60628317eb08d5ac46ddb320a07db038111803702129f70b2ee897b546bc84f25708a720f980a790ec7bf99fad8f5110a6bb82c475f12ba291003dfa416b945677aa7b70b809fcf4bfcc73b147c91722bed1d0be4c6dab43a66e19c150d8190ff6920889625850312b847991d113474a814248f82f983ccbf706f42e4bd63b459fb560fadab4a7bdcf18dcc83729889ae6e2041","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"aa9c6699050542c8b4afa6887efc3956"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
